import{_ as Y,c as N,o as B,a5 as C}from"./chunks/framework.CUWTb1PO.js";const T={mounted(){const r=new Map;function p(n){const a=n.querySelectorAll("a[href]");for(const e of a){const i=e.href,l=r.get(i)??new Set;l.add(e),r.set(i,l)}for(const e of a)e.onmouseover=function(){for(const i of r.get(this.href))i.classList.add("hover-highlight")},e.onmouseout=function(){for(const i of r.get(this.href))i.classList.remove("hover-highlight")}}function m(n){return decodeURIComponent(atob(n).split("").map(function(a){return"%"+("00"+a.charCodeAt(0).toString(16)).slice(-2)}).join(""))}const j=(n=>{const a={};return(...e)=>{const i=JSON.stringify(e);return a[i]=a[i]||n(...e)}})(m);class w{constructor(){this.list=[]}dismiss(a){a&&(a.remove(),this.list=this.list.filter(e=>e!==a))}dismissIfNotUsed(a){a&&(a.markedForDismissal=!0,setTimeout(()=>{!a.userIsThinking&&this.allowAutoDismissal(a)&&this.dismiss(a)},1e3))}allowAutoDismissal(a){return a.markedForDismissal&&!a.userClicked}fireAutoDismissalFor(a){let e=this.list.find(i=>i.userCreatedFrom===a);this.dismissIfNotUsed(e)}createHoverFor(a,e,i){let l=this.list.find(s=>s.userCreatedFrom===a);if(l&&l.userClicked)return l;let f=[];const v=this.list.filter(s=>{if(this.allowAutoDismissal(s))return f.push(s),!1;const o=s.userCreatedFrom,P=a;let c=P;for(;c;){if(c===o)return!0;c=c.parentElement}for(c=o;c;){if(c===P)return!0;c=c.parentElement}return!1});f.forEach(s=>this.dismiss(s));let t=document.createElement("div");t.userCreatedFrom=a,t.innerHTML="<span class='AyaTooltipPopupClose'></span>"+j(e),t.classList.add("AyaTooltipPopup"),p(t);let b=this;t.handleEvent=function(s){if(s.type==="click"){this.userClicked=!0,this.markedForDismissal=!1;let o=this.children[0];if(!o)return;let P=this;t.classList.add("TooltipPinned"),o.addEventListener("click",c=>b.dismiss(P))}s.type==="mouseover"&&(this.userIsThinking=!0),s.type==="mouseout"&&(this.userIsThinking=!1,b.dismissIfNotUsed(this))},t.addEventListener("click",t),t.addEventListener("mouseover",t),t.addEventListener("mouseout",t),i.appendChild(t);const d=a.getBoundingClientRect();let G=t.getBoundingClientRect();const y=window.scrollX,g=window.scrollX+document.documentElement.clientWidth,u=8;let h=d.left+window.scrollX;if(h+G.width+u>g&&(h=g-G.width-u),h<y+u&&(h=y+u),t.style.left=`${h}px`,v.length===0)if(d.bottom+G.height+30>window.innerHeight){const o=d.top+window.scrollY-G.height-8;t.style.top=`${o}px`}else{const o=d.bottom+window.scrollY+8;t.style.top=`${o}px`}else{const s=Math.max(...v.map(o=>o.offsetTop+o.offsetHeight));t.style.top=`${s+8}px`}return this.list.push(t),t}}let F=new w;function I(n){return function(){let a=this;const e=a.getAttribute("data-tooltip-text");e&&(n?F.createHoverFor(a,e,document.body):F.fireAutoDismissalFor(a))}}p(document);{let n=document.getElementsByClassName("aya-tooltip");for(let a=0;a<n.length;a++){let e=n[a];e.hasAttribute("data-tooltip-text")&&(e.onmouseover=I(!0),e.onmouseout=I(!1))}}}},k=JSON.parse('{"title":"An IR for Aya","description":"","frontmatter":{"lastUpdated":"2025-11-15T01:33:05.000Z"},"headers":[],"relativePath":"blog/anf-ir.md","filePath":"blog/anf-ir.md","lastUpdated":1763170385000}');function Z(r,p,m,z,j,w){return B(),N("div",null,[...p[0]||(p[0]=[C(`<h1 id="an-ir-for-aya" tabindex="-1">An IR for Aya <a class="header-anchor" href="#an-ir-for-aya" aria-label="Permalink to “An IR for Aya”">​</a></h1><p>In the <a href="./jit-compile.html">previous blog post</a>, we introduced the architecture of the Aya JIT compiler, where the unfolding behavior (and several other related things) of function definitions are compiled into JVM bytecode.</p><p>We have optimized the compilation process since then, by introducing an intermediate representation (IR) for it, so we have an opportunity to perform some basic optimizations and transformations on the IR before generating JVM bytecode.</p><p>The Aya compilation pipeline goes through the following stages, where - means the result of the previous stage:</p><ul><li>parsing (<code>AyaParser</code>) : Source code (<code>String</code>) → Parse tree (<code>GenericNode</code>)</li><li>basic syntax checking : - → Concrete syntax tree (<code>Expr</code>)</li><li>resolving and desugaring : - → Concrete syntax tree (<code>Expr</code>)</li><li>type checking : - → Core language (<code>CoreExpr</code>)</li><li>compilation : - → Aya IR (<code>AyaIR</code>)</li><li>JVM bytecode generation : - → JVM class files</li></ul><p>There are three important languages: the concrete syntax tree, the core language, and the IR. If you&#39;re familiar with Rust, the concrete syntax tree is like the HIR, the core language is like the THIR, and the Aya IR is like MIR. If you&#39;re unfamiliar with Rust but you know how Aya IR works, then you basically know how Rust IR works too. This is completely coincidental.</p><p>A related change is that we now have <code>let</code> expressions in the core, which is a β-redex. They will be reduced when checking conversion, but will be kept after type checking. They play a significant role in the code generation and optimization.</p><h2 id="a-normal-form" tabindex="-1">A-Normal Form <a class="header-anchor" href="#a-normal-form" aria-label="Permalink to “A-Normal Form”">​</a></h2><p>The IR does not allow expressions to nest, unlike in the core language. So, terms like <code>f (g x) + h y</code> will be transformed into</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = FnCall(g, x)
<span class="Keyword">let</span> var1 = FnCall(f, var0)
<span class="Keyword">let</span> var2 = FnCall(h, y)
<span class="Keyword">let</span> var3 = FnCall(Add, var1, var2)</code>
</pre><p>and the use of this expression will be replaced by <code>var3</code>.</p><p>To different audiences, this form may resemble different things:</p><ul><li>For functional programmers, this is similar to A-normal form (ANF), which is an IR for functional languages where arguments to functions must be trivial (either constants or variables).</li><li>For compilers, this is similar to three-address code (TAC), except that function calls in Aya allow arbitrary many arguments, so it&#39;s more like &quot;n-address code&quot;.</li></ul><p>For binding structures, we compile them into a JVM lambda function wrapped in a <code>Closure</code> expression. For example, the core language term <code>f (λx. x + 1)</code> will be compiled into</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = Closure(x → {
    <span class="Keyword">let</span> var1 = FnCall(Add, x, 1)
    return var1
  })
<span class="Keyword">let</span> var1 = FnCall(f, var0)</code>
</pre><p>And function definitions are compiled into top-level functions.</p><p>Now, what benefits does this form bring us?</p><h2 id="let-elimination" tabindex="-1">Let-elimination <a class="header-anchor" href="#let-elimination" aria-label="Permalink to “Let-elimination”">​</a></h2><p>We mentioned earlier that we now have <code>let</code> expressions in the core language. We can compile <code>let</code> expreessions directly into the <code>let</code> in the IR, and this is referred to as &quot;let-elimination&quot;.</p><p>Consider the core language term <code>let x = f y in g x x</code>. Using let-elimination it will be compiled into</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = FnCall(f, y)
<span class="Keyword">let</span> var1 = FnCall(g, var0, var0)</code>
</pre><p>Without let-elimination or let expressions in the core language, this be represented in the core as <code>g (f y) (f y)</code>, which will be compiled into</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = FnCall(f, y)
<span class="Keyword">let</span> var1 = FnCall(f, y)
<span class="Keyword">let</span> var2 = FnCall(g, var0, var1)</code>
</pre><p>which is not good because of the duplicated computation. By the way, it&#39;s possible to have <code>let</code> expressions in the core language and not let-elimination, which will compile the above into</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = FnCall(f, y)
<span class="Keyword">let</span> var1 = Closure(x → FnCall(g, x, x))
<span class="Keyword">let</span> var2 = Let(var0, var1)</code>
</pre><p>which is also not good because of the unnecessary closure creation.</p><p>Let-elimination guarantees that <code>let</code> introduced by the type checker will be preserved in the IR. We have replaced several things with <code>let</code> expressions in the core language to take advantage of this, such as the use of function parameters with the presence of pattern matching. For example,</p><pre class="Aya"><code><span class="Keyword">def</span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a id="Mian-foo" href="#Mian-foo"><span class="Fn">foo</span></a></span> (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v616881582" href="#v616881582"><span class="LocalVar">param</span></a></span> : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>) : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#Mian-Nat-zero"><span class="Constructor">zero</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v616881582"><span class="LocalVar">param</span></a></span> <span class="Comment">// notice the use of \`param\`</span>
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a href="#Mian-Nat-suc"><span class="Constructor">suc</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v939199469" href="#v939199469"><span class="LocalVar">patternVar</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v616881582"><span class="LocalVar">param</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-2b"><span class="Fn">+</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v939199469"><span class="LocalVar">patternVar</span></a></span> <span class="Comment">// notice the use of \`param\`</span></code>
</pre><p>Due to the semantics of pattern matching, the <code>param</code> in the first clause is replaced with <code>zero</code>, and the <code>param</code> in the second clause is replaced with <code>suc patternVar</code>. This will introduce some duplication if <code>param</code> is used multiple times. We now compile this substitution as <code>let</code> bindings in the beginning of the clause body.</p><h2 id="tail-recursion-optimization" tabindex="-1">Tail-recursion optimization <a class="header-anchor" href="#tail-recursion-optimization" aria-label="Permalink to “Tail-recursion optimization”">​</a></h2><p>Aya supports explicitly annotated tail-recursive functions:</p><pre class="Aya"><code><span class="Keyword">def</span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a id="Mian-fac-rec" href="#Mian-fac-rec"><span class="Fn">fac-rec</span></a></span> (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v85748029" href="#v85748029"><span class="LocalVar">n</span></a></span> : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>) : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#Mian-Nat-zero"><span class="Constructor">zero</span></a></span> ⇒ 1
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a href="#Mian-Nat-suc"><span class="Constructor">suc</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v1784131088" href="#v1784131088"><span class="LocalVar">k</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a href="#Mian-fac-rec"><span class="Fn">fac-rec</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v1784131088"><span class="LocalVar">k</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-2a"><span class="Fn">*</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v85748029"><span class="LocalVar">n</span></a></span>

<span class="Keyword">tailrec</span> <span class="Keyword">def</span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a id="Mian-fac-aux" href="#Mian-fac-aux"><span class="Fn">fac-aux</span></a></span> (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v528591360" href="#v528591360"><span class="LocalVar">n</span></a></span> : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>) (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v1801942731" href="#v1801942731"><span class="LocalVar">acc</span></a></span> : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>) : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#Mian-Nat-zero"><span class="Constructor">zero</span></a></span>, <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v409195262" href="#v409195262"><span class="LocalVar">acc</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v409195262"><span class="LocalVar">acc</span></a></span>
| <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a href="#Mian-Nat-suc"><span class="Constructor">suc</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v394771492" href="#v394771492"><span class="LocalVar">k</span></a></span>, <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v88397182" href="#v88397182"><span class="LocalVar">acc</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-fac-aux"><span class="Fn">fac-aux</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v394771492"><span class="LocalVar">k</span></a></span> (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v88397182"><span class="LocalVar">acc</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-2a"><span class="Fn">*</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v528591360"><span class="LocalVar">n</span></a></span>)

<span class="Keyword">def</span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+PC9jb2RlPgo8L3ByZT4K"><a id="Mian-fac" href="#Mian-fac"><span class="Fn">fac</span></a></span> (<span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a id="v765242091" href="#v765242091"><span class="LocalVar">n</span></a></span> : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span>) : <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPjxzcGFuIGNsYXNzPSJLZXl3b3JkIj5UeXBlPC9zcGFuPiAwPC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-Nat"><span class="Data">Nat</span></a></span> ⇒ <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT4g4oaSIDxhIGhyZWY9IiNNaWFuLU5hdCI+PHNwYW4gY2xhc3M9IkRhdGEiPk5hdDwvc3Bhbj48L2E+IOKGkiA8YSBocmVmPSIjTWlhbi1OYXQiPjxzcGFuIGNsYXNzPSJEYXRhIj5OYXQ8L3NwYW4+PC9hPjwvY29kZT4KPC9wcmU+Cg=="><a href="#Mian-fac-aux"><span class="Fn">fac-aux</span></a></span> <span class="aya-tooltip" data-tooltip-text="PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PGEgaHJlZj0iI01pYW4tTmF0Ij48c3BhbiBjbGFzcz0iRGF0YSI+TmF0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="><a href="#v765242091"><span class="LocalVar">n</span></a></span> 1</code>
</pre><p>The function <code class="Aya"><a href="#Mian-fac-rec"><span class="Fn">fac-rec</span></a></code> is a recursive implementation of factorial as a reference, while <code class="Aya"><a href="#Mian-fac-aux"><span class="Fn">fac-aux</span></a></code> is a tail-recursive implementation of factorial with an accumulator. The <code>tailrec</code> modifier makes the compiler to check all recursive calls to be at the top-level of the clause bodies, which will guarantee the generated IR to have these recursive calls at tail positions. Then we can optimize them in the JIT-compiled code (there&#39;s no optimization in the interpreter yet).</p><p>This looks trivial, as we can just compile the function into a while loop, and for each tail recursion, we reassign the function parameters and <code>continue</code> the loop. However, since we now introduce these <code>let</code> expressions, the function body may not be just a recursive call, but a recursive call wrapped in a <code>let</code> expression. Consider the second clause of <code class="Aya"><a href="#Mian-fac-aux"><span class="Fn">fac-aux</span></a></code>:</p><pre class="Aya"><code><span class="Comment">// what you might think the core term looks like:</span>
FnCall(fac-aux, k, FnCall(*, acc, n))

<span class="Comment">// what the core term actually looks like:</span>
Let(ConCall(suc, k), n →
  FnCall(fac-aux, k, FnCall(*, acc, n)))</code>
</pre><p>We want the function body to be <code>FnCall(fac-aux, ..)</code>, not a <code>let</code>. But with let-elimination, it&#39;s actually what&#39;s inside the <code>let</code> body that will be at the tail position. So we can relax the tail-recursion requirement to look inside <code>let</code> expressions.</p><p>These two features work together nicely!</p><h2 id="dataflow-analysis" tabindex="-1">Dataflow analysis <a class="header-anchor" href="#dataflow-analysis" aria-label="Permalink to “Dataflow analysis”">​</a></h2><p>With the IR in A-normal form, it&#39;s easy to perform certain optimizations on the code.</p><p>Consider the expression <code>f (g x) (g x)</code>, it is obvious that the <code>g x</code> is computed twice, and it would be nice if we can merge them into one computation. However, there can be potentially very complex expressions, and looking for common sub-expressions will be very complicated, because comparing subexpressions is expensive.</p><p>Not good!</p><p>Using ANF, the expressions are always flat:</p><pre class="Aya"><code><span class="Keyword">let</span> var0 = FnCall(g, x)
<span class="Keyword">let</span> var1 = FnCall(g, x)
<span class="Keyword">let</span> var2 = FnCall(f, var0, var1)</code>
</pre><p>We can build a table of expressions and the lookup will be linear time in the number of <code>let</code> bindings.</p><p>Much better!</p><p>In fact, since Aya is a pure language, without the tail-recursion optimization, the IR is already in SSA form, so a lot of analysis techniques from SSA can be applied here, and we can do a lot of optimizations.</p><p>With tail-recursion, there is mutation of function parameters, but that&#39;s the only place where we need to introduce some φ-nodes, so most SSA techniques still apply.</p><h2 id="trying-and-testing" tabindex="-1">Trying and testing <a class="header-anchor" href="#trying-and-testing" aria-label="Permalink to “Trying and testing”">​</a></h2><p>In the Aya repl, you can use <code>:optimized-anf</code> command followed by a function to see the ANF IR generated for it:</p><pre class="Aya"><code>&gt; :optimize-anf fac
__58theKid.invoke(UnaryOperator, Term) → Term
  <span class="Keyword">let</span> %0: IntegerTerm := invoke _base$_base_Nat.makeInteger (1)
  <span class="Keyword">let</span> %1: Term := invoke __58theKid$__58theKid_fac_45aux.invoke (arg%0, arg%1, %0)
  return %1
&gt; :optimize-anf fac-aux
__58theKid$__58theKid_fac_45aux.invoke(UnaryOperator, Term, Term) → Term
  loop
    <span class="Keyword">let</span> %0: Term := null
    <span class="Keyword">let</span> %1: Term := null
    <span class="Keyword">let</span> %2: int := 0
    <span class="Keyword">let</span> %3: boolean := false
    breakable
      <span class="Keyword">let</span> %4: Object := invoke arg%0.apply(arg%1)
      <span class="Keyword">let</span> %5: Term := checkcast %4 Term
      if <span class="Keyword">let</span> %6: ConCallLike := %5
        <span class="Keyword">let</span> %7: ConDefLike := invoke %6.ref()
        <span class="Keyword">let</span> %8: _base$_base_Nat_zero := _base$_base_Nat_zero.INSTANCE
        if ref eq %7 %8
          %0 := arg%2
          %2 := 1
          break
      else
        break
      <span class="Keyword">let</span> %6: Object := invoke arg%0.apply(arg%1)
      <span class="Keyword">let</span> %7: Term := checkcast %6 Term
      if <span class="Keyword">let</span> %8: ConCallLike := %7
        <span class="Keyword">let</span> %9: ConDefLike := invoke %8.ref()
        <span class="Keyword">let</span> %10: _base$_base_Nat_suc := _base$_base_Nat_suc.INSTANCE
        if ref eq %9 %10
          <span class="Keyword">let</span> %11: ImmutableSeq := invoke %8.conArgs()
          <span class="Keyword">let</span> %12: Object := invoke %11.get(0)
          <span class="Keyword">let</span> %13: Term := checkcast %12 Term
          %0 := %13
          %1 := arg%2
          %2 := 2
    switch %2 amongst 3
      case 0 →
        <span class="Keyword">let</span> %4: __58theKid$__58theKid_fac_45aux := __58theKid$__58theKid_fac_45aux.INSTANCE
        <span class="Keyword">let</span> %5: ImmutableSeq := invoke ImmutableSeq.of(arg%1, arg%2)
        <span class="Keyword">let</span> %6: FnCall := <span class="Keyword">new</span> (%4, 0, %5)
        return %6
      case 1 → return %0
      default
        <span class="Keyword">let</span> %4: _base$_base_Nat_suc := _base$_base_Nat_suc.INSTANCE
        <span class="Keyword">let</span> %5: IntegerTerm := invoke _base$_base_Nat.makeInteger(0)
        <span class="Keyword">let</span> %6: IntegerOps$ConRule := <span class="Keyword">new</span> (%4, %5)
        <span class="Keyword">let</span> %7: ImmutableSeq := invoke ImmutableSeq.empty()
        <span class="Keyword">let</span> %8: ImmutableSeq := invoke ImmutableSeq.of(%0)
        <span class="Keyword">let</span> %9: RuleReducer$Con := <span class="Keyword">new</span> (%6, 0, %7, %8)
        <span class="Keyword">let</span> %10: Term := invoke %9.make()
        <span class="Keyword">let</span> %11: Term := invoke _base$_base__42.invoke(arg%0, %1, %10)
        arg%1 := %0
        arg%2 := %11
        continue</code>
</pre><p>A few remarks on the output:</p><ul><li>The function names are mangled to include the module name and special characters are replaced with their ASCII codes.</li><li>The first parameter of <code>invoke</code> is a normalizer for computing the WHNF of terms, which is used in the pattern matching state machine,</li><li><code>%2</code> indicats which clause is matched, which is used in the <code>switch</code> statement later, where <code>0</code> means stuck, and it will return the original function call as-is,</li><li>The <code>default</code> case in the <code>switch</code> statement is the tail-recursive call, which reassigns the function parameters and continues the loop,</li><li>This result of code generation is a mixture of both high-level constructs like <code>breakable</code> and some low-level JVM stuff. This is temporary. We might introduce some further abstractions in the future.</li></ul><p>Thank you for reading!</p>`,53)])])}const S=Y(T,[["render",Z]]);export{k as __pageData,S as default};
