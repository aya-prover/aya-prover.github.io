import{_ as t,c as a,o as n,a5 as i}from"./chunks/framework.CUWTb1PO.js";const u=JSON.parse('{"title":"Index unification and forced patterns in Aya","description":"","frontmatter":{},"headers":[],"relativePath":"blog/index-unification.md","filePath":"blog/index-unification.md","lastUpdated":1718066705000}'),o={name:"blog/index-unification.md"};function s(c,e,d,r,l,p){return n(),a("div",null,[...e[0]||(e[0]=[i(`<h1 id="index-unification-and-forced-patterns-in-aya" tabindex="-1">Index unification and forced patterns in Aya <a class="header-anchor" href="#index-unification-and-forced-patterns-in-aya" aria-label="Permalink to â€œIndex unification and forced patterns in Ayaâ€">â€‹</a></h1><p>Aya implements a version of index unification algorithm that allows omission of obvious patterns. Here&#39;s an example. Consider the famous &quot;sized-vector&quot; <code>Vec (n : Nat) (A : Type)</code> definition, and we can perform some pattern matching:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>len : âˆ€ {A} -&gt; (n : Nat) -&gt; Vec n A -&gt; Nat</span></span>
<span class="line"><span>len a vnil = 0</span></span>
<span class="line"><span>len a (vcons _ x) = suc (len _ x)</span></span></code></pre></div><p>This code may seem obviously correct, but why would I write about it if it&#39;s so simple? ðŸ˜‰ Let&#39;s run the type checking in our head, clause by clause and pattern by pattern.</p><ol start="0"><li>The first pattern in the first clause, <code>a</code>, is a valid pattern for <code>Nat</code>. This means we will substitute the codomain of the pattern matching with <code>[a/n]</code>, where <code>n</code> is the corresponding name <em>in the telescope</em> and <code>a</code> is the term corresponding to the pattern.</li><li>The second pattern in the first clause, <code>vnil</code>, is a pattern for <code>Vec zero A</code>. However, the expected type is <code>Vec a A</code>, which does not match the type of the pattern.</li></ol><p>So, here is the problem! The well-typed version of the program is actually:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>len : âˆ€ {A} -&gt; (n : Nat) -&gt; Vec n A -&gt; Nat</span></span>
<span class="line"><span>len zero vnil = 0</span></span>
<span class="line"><span>len (suc a) (vcons _ x) = suc (len a x)</span></span></code></pre></div><p>However, isn&#39;t it obvious that the first pattern in the first clause must be <code>zero</code>? It would be nice if the type checker can figure this out by itself. In fact, both Agda and Idris can do this! In Agda, the feature is called &quot;dotted patterns&quot; in the documentation and &quot;inaccessible patterns&quot; in the paper. I will prefer calling it &quot;forced patterns&quot; because the patterns are actually accessible (in the sense that the bindings in the patterns are used) and does not use the Agda dot syntax.</p><p>Forced patterns are not easy to implement. The simplest pattern type checking algorithm can be quite straightforward: we check the type of the pattern, add the bindings to the context so we can type the rest of the telescope, and check the body of the clause. With forced patterns, we will need to change the existing well-typed variable patterns into constructor patterns, so the algorithm becomes stateful.</p><p>In Aya, I introduced the concept of &quot;meta patteriables&quot; which is a funny reference to &quot;meta variables&quot; used in unification in conversion check.</p><h2 id="the-so-called-meta-patteriables" tabindex="-1">The so-called &quot;meta patteriables&quot; <a class="header-anchor" href="#the-so-called-meta-patteriables" aria-label="Permalink to â€œThe so-called &quot;meta patteriables&quot;â€">â€‹</a></h2><p>Related PR: <a href="https://github.com/aya-prover/aya-dev/pull/198" target="_blank" rel="noreferrer">#198</a></p><p>When we see a variable pattern, we transform it into a <code>MetaPat</code> which is a &quot;unification variable&quot; pattern that can be &quot;solved&quot; into another pattern. A reference to a <code>MetaPat</code> is converted into a special meta variable that has a mutable reference to the <code>MetaPat</code> (this can be replaced by a mutable map in the type checking state when you need purity, but I prefer mutable references for implementation simplicity).</p><p>When we are type checking a pattern of type <code>D a</code> for <code>D</code> an indexed inductive family and the expected type is <code>D b</code> where <code>b</code> is the special meta variable, we claim that <code>b</code> is <em>solved</em> to <code>a</code>, and the <code>MetaPat</code> that corresponds to <code>b</code> will be transformed into <code>a</code> when we finalize the type checking results.</p><p>There are two more cases to deal with:</p><ol start="0"><li>In case a <code>MetaPat</code> is not &quot;solved&quot;, we just let it be a variable pattern.</li><li>In case a <code>MetaPat</code> is &quot;solved&quot; more than once, we must make sure the solutions are identical.</li></ol><p>Note that a <code>MetaPat</code> may contain bindings, but these bindings are already from the current context, so we do not need to add them again to the context.</p><p>Now, let&#39;s run the new algorithm:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>len : âˆ€ {A} -&gt; (n : Nat) -&gt; Vec n A -&gt; Nat</span></span>
<span class="line"><span>len a vnil = 0</span></span>
<span class="line"><span>len a (vcons _ x) = suc (len _ x)</span></span></code></pre></div><ol start="0"><li>The first pattern in the first clause, <code>a</code>, is a valid pattern for <code>Nat</code>, so we generate a <code>MetaPat(a)</code> and substitute the codomain with <code>MetaPatRef(a)</code>, e.g. <code>Vec MetaPatRef(a) A -&gt; Nat</code>.</li><li>The second pattern in the first clause, <code>vnil</code>, is a pattern for <code>Vec zero A</code>. The expected type is <code>Vec MetaPatRef(a) A</code>, and we solve <code>MetaPat(a)</code> to <code>zero</code>.</li><li>Now we check the body and finalize the clause. Since <code>a</code> is solved to <code>zero</code>, we generate the well-typed clause <code>len zero vnil = 0</code> which is exactly what we need.</li></ol><p>Thanks for reading!</p>`,21)])])}const f=t(o,[["render",s]]);export{u as __pageData,f as default};
