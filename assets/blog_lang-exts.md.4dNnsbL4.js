import{_ as a,c as t,o as s,a5 as i}from"./chunks/framework.CUWTb1PO.js";const g=JSON.parse('{"title":"Haskell or Agda style extensions","description":"","frontmatter":{},"headers":[],"relativePath":"blog/lang-exts.md","filePath":"blog/lang-exts.md","lastUpdated":1739341094000}'),o={name:"blog/lang-exts.md"};function n(r,e,l,c,d,h){return s(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="haskell-or-agda-style-extensions" tabindex="-1">Haskell or Agda style extensions <a class="header-anchor" href="#haskell-or-agda-style-extensions" aria-label="Permalink to “Haskell or Agda style extensions”">​</a></h1><p>In Haskell, you can do <code>{-# LANGUAGE TypeFamilies #-}</code>, and similarly in Agda you can <code>{-# OPTIONS --two-levels #-}</code>. These &quot;pragma&quot; can also be specified via command line arguments. Since Haskell is too weak and even basic features need extensions, I&#39;ll be avoiding talking about it and stick to Agda.</p><h2 id="agda-s-extensions" tabindex="-1">Agda&#39;s extensions <a class="header-anchor" href="#agda-s-extensions" aria-label="Permalink to “Agda&#39;s extensions”">​</a></h2><p>The purpose of these pragma is threefold:</p><ul><li>Disable or enable (particularly disable) certain checks or compiler phases such as positivity checks, termination checks, deletion rule in unification, etc.</li><li>Modify the compiler by changing some parameters, such as termination check&#39;s recursion depth, use call-by-name instead of call-by-need, cumulativity, etc.</li><li>Disable or enable (particularly enable) certain language features, such as cubical features, sized types, custom rewriting rules, etc.</li></ul><p>One special pragma is to ensure that no known inconsistent flag or combination of flags is turned on -- <code>--safe</code>. Let&#39;s discuss it later.</p><p>The current status of Agda libraries, that having separate cubical, HoTT library, and standard library, implementing the basic features individually, is a significant evidence that Agda is barely a programming language, but a collection of programming languages that share a lot in common and have good interoperability. Each flag that enables a certain language feature makes Agda a different language, and it is difficult in general to make two different language source-to-source compatible (see Kotlin-Java, Scala-Java, etc.).</p><p>It is good to keep your language evolving like Agda (adding new features aggressively), and indeed Agda is <strong>the</strong> proof assistant with the richest set of language features I&#39;ve known so far. However, this also negatively impacts Agda&#39;s reputation to some extent, that people say it&#39;s an <a href="https://youtu.be/Dp-mQ3HxgDE?t=3934" target="_blank" rel="noreferrer">experiment in type theory</a>. Well, maybe it&#39;s not a negative impact, but it prevents big customers (such as Mathematicians looking for a tool to formalize math) from choosing the language. At least, we don&#39;t want this to happen to our language.</p><h2 id="aya-s-choice" tabindex="-1">Aya&#39;s choice? <a class="header-anchor" href="#aya-s-choice" aria-label="Permalink to “Aya&#39;s choice?”">​</a></h2><p>So, we will not introduce any &quot;feature&quot; flags, and will have only one base library. Aya will be one language, its features are its features. If we decide on removing a feature, then we remove it from the language (not going to keep it as an optional flag). If we decide on adding a feature, we add it, and it should be available without any options.</p><p>It should still be encouraged to add some fancy, experimental features, but I think they should stay in branches or forks and will be either enlisted to the language or abandoned eventually.</p><p>However, the &quot;parameters&quot; part is not as bad. For example, it is very easy to allow type-in-type in the type checker -- we just disable the level solver. This is useful when the level solver prevents us from experimenting something classical using our language features but unfortunately the level solver is just unhappy with something minor. We can also like tweak the conversion checking algorithm we use, like we can use a simpler one that only solves first-order equations, or we can enable the full-blown pattern unification algorithm. Verbosity levels, can also be seen as such parameter, and it&#39;s extremely useful for debugging the compiler. So we can apply that.</p><h3 id="safe-flag" tabindex="-1">Safe flag? <a class="header-anchor" href="#safe-flag" aria-label="Permalink to “Safe flag?”">​</a></h3><p>To be honest, it&#39;s hard to decide on a semantic of the word &quot;safe&quot;, and relate that to the Agda pragma <code>--safe</code>. To me, it means &quot;logical consistency&quot;, and if we can set <code>--safe</code> as the last argument of an Agda file, it should be guaranteed by Agda that it cannot provide you a proof of false. There <a href="https://github.com/agda/agda/issues/3564#issuecomment-464102606" target="_blank" rel="noreferrer">are</a> many <a href="https://github.com/agda/agda/issues/4560#issuecomment-609001957" target="_blank" rel="noreferrer">related</a> discussion <a href="https://github.com/agda/agda/issues/3315#issuecomment-436905598" target="_blank" rel="noreferrer">in</a> the Agda <a href="https://github.com/agda/agda/issues/4450#issuecomment-586891969" target="_blank" rel="noreferrer">issue</a> tracker <a href="https://github.com/agda/agda/issues/3626#issuecomment-472159808" target="_blank" rel="noreferrer">that</a> talks &#39;bout how should <code>--safe</code> behave. Sometimes it fits my guess (for logical consistency), sometimes it implies more stuffs.</p><p>Anyway, a &quot;logical consistency&quot; flag seems useful, and will probably appear in Aya.</p><p>For disabling or enabling some checks, if we disable a check that is required to be consistent, then it should break <code>--safe</code>. I think we will of course enable all of these checks by default, so exploiting the disabledness of a check can lead to inconsistency eventually. So, we can use an &quot;unsafe&quot; flag to ensure that our language is only unsafe when we want it to be. It is quite meaningful as well to have an &quot;unsafe&quot; mode, from a real-world programming perspective.</p><h3 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to “Conclusion”">​</a></h3><p>We&#39;ll have a language, with some flags that tweaks the parameters of some algorithms (which are no-harm), and some flags for disabling some checks (which will lead to an error at the end of tycking), and an unsafe flag that enables a set of features such as <code>sorry</code> and suppresses the error of disabling checks.</p><h2 id="library-design" tabindex="-1">Library Design <a class="header-anchor" href="#library-design" aria-label="Permalink to “Library Design”">​</a></h2><p>Speaking of the base library design, I have some vague ideas in mind. I&#39;d like it to be split into three parts (not sure if we&#39;re gonna make it three modules inside one stdlib or three standalone libraries):</p><ul><li>The base part, for basic definitions like lists, trees, sorting, rings, categories, path lemmas, simple tactics like rewrites, etc.</li><li>The programming part, for I/O, effects, unsafe operations, FFI, etc.</li><li>The math part, like arend-lib or Lean&#39;s mathlib.</li></ul><p>Then, we can use these libraries on-demand.</p>',22)])])}const f=a(o,[["render",n]]);export{g as __pageData,f as default};
