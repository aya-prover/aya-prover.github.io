import{_ as w,c as N,o as F,a2 as h,j as a,a as s}from"./chunks/framework.BV7BAn2o.js";const M={mounted(){const d=new Map;function y(r){const e=r.querySelectorAll("a[href]");for(const t of e){const o=t.href,p=d.get(o)??new Set;p.add(t),d.set(o,p)}for(const t of e)t.onmouseover=function(){for(const o of d.get(this.href))o.classList.add("hover-highlight")},t.onmouseout=function(){for(const o of d.get(this.href))o.classList.remove("hover-highlight")}}function u(r){return decodeURIComponent(atob(r).split("").map(function(e){return"%"+("00"+e.charCodeAt(0).toString(16)).slice(-2)}).join(""))}const k=(r=>{const e={};return(...t)=>{const o=JSON.stringify(t);return e[o]=e[o]||r(...t)}})(u);class f{constructor(){this.list=[]}dismiss(e){e&&(e.remove(),this.list=this.list.filter(t=>t!==e))}dismissIfNotUsed(e){e&&(e.markedForDismissal=!0,setTimeout(()=>{!e.userIsThinking&&this.allowAutoDismissal(e)&&this.dismiss(e)},1e3))}allowAutoDismissal(e){return e.markedForDismissal&&!e.userClicked}fireAutoDismissalFor(e){let t=this.list.find(o=>o.userCreatedFrom===e);this.dismissIfNotUsed(t)}createHoverFor(e,t,o){let p=this.list.find(i=>i.userCreatedFrom===e);if(p&&p.userClicked)return p;let x=[];const A=this.list.filter(i=>{if(this.allowAutoDismissal(i))return x.push(i),!1;const l=i.userCreatedFrom,v=e;let c=v;for(;c;){if(c===l)return!0;c=c.parentElement}for(c=l;c;){if(c===v)return!0;c=c.parentElement}return!1});x.forEach(i=>this.dismiss(i));let n=document.createElement("div");n.userCreatedFrom=e,n.innerHTML="<span id='AyaTooltipPopupClose'>&times;</span>"+k(t),n.classList.add("AyaTooltipPopup"),y(n);let b=this;if(n.handleEvent=function(i){if(i.type==="click"){this.userClicked=!0,this.markedForDismissal=!1;let l=this.children[0];if(!l)return;let v=this;l.style.visibility="visible",l.addEventListener("click",c=>b.dismiss(v))}i.type==="mouseover"&&(this.userIsThinking=!0),i.type==="mouseout"&&(this.userIsThinking=!1,b.dismissIfNotUsed(this))},n.addEventListener("click",n),n.addEventListener("mouseover",n),n.addEventListener("mouseout",n),o.appendChild(n),n.style.left=`${e.offsetLeft}px`,A.length===0){const i=e.getBoundingClientRect(),l=n.getBoundingClientRect();i.bottom+l.height+30>window.innerHeight?n.style.top=`calc(${e.offsetTop-l.height+8}px - 3em)`:n.style.top=`${e.offsetTop+e.offsetHeight+8}px`}else{const i=Math.max(...A.map(l=>l.offsetTop+l.offsetHeight));n.style.top=`${i+8}px`}return this.list.push(n),n}}let m=new f;function g(r){return function(){let e=this;const t=e.getAttribute("data-tooltip-text");t&&(r?m.createHoverFor(e,t,document.body):m.fireAutoDismissalFor(e))}}y(document);{let r=document.getElementsByClassName("aya-tooltip");for(let e=0;e<r.length;e++){let t=r[e];t.hasAttribute("data-tooltip-text")&&(t.onmouseover=g(!0),t.onmouseout=g(!1))}}}},C=JSON.parse('{"title":"So you know some Haskell","description":"","frontmatter":{"lastUpdated":"2024-12-15T22:37:34.000Z"},"headers":[],"relativePath":"guide/haskeller-tutorial.md","filePath":"guide/haskeller-tutorial.md","lastUpdated":1734302254000}');function V(d,y,u,T,k,f){return F(),N("div",null,y[0]||(y[0]=[h('<h1 id="so-you-know-some-haskell" tabindex="-1">So you know some Haskell <a class="header-anchor" href="#so-you-know-some-haskell" aria-label="Permalink to &quot;So you know some Haskell&quot;">​</a></h1><p>Great. I expect you to know something about GHCi and algebraic data types. This is an Aya tutorial for Haskell programmers. If you find a bug, open an issue on GitHub!</p><h2 id="working-with-the-repl" tabindex="-1">Working with the REPL <a class="header-anchor" href="#working-with-the-repl" aria-label="Permalink to &quot;Working with the REPL&quot;">​</a></h2><p>Aya has a REPL that works similar to GHCi. You can start it by running <code>aya -i</code> in your terminal, and you can start typing definitions or expressions.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aya</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span></span></code></pre></div><p>If you&#39;re using jar with java, use the following instead:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --enable-preview</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cli-fatjar.jar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span></span></code></pre></div><p>In the REPL, you can use <code>:l</code> to load a file, <code>:q</code> to quit, and <code>:?</code> to get help. Use <code>:t</code> to show the type. Since it&#39;s dependent type, you can toggle normalization levels by <code>:normalize</code> followed by <code>NF</code>, <code>WHNF</code>, or <code>NULL</code> (don&#39;t normalize).</p><p>To work multiline, use the pair <code>:{</code> and <code>:}</code> -- same as GHCi.</p><p>Aya supports pretty-printing of <em>any</em> terms, including ✨lambdas✨. Note that Aya does not automatically support generic lambdas, so typing <code>\\x =&gt; x</code> would not work. You need to specify the type of <code>x</code>, like <code>\\(x : Int) =&gt; x</code>.</p><p>Aya support <code>fn</code> as an alias to <code>\\</code> instead of <code>λ</code>, similar to Coq and Lean (but not Agda). This is because users (especially mathematicians) are likely to use <code>λ</code> as a variable name. Similarly, we used <code>Fn</code> over <code>Pi</code> or <code>Π</code> for the same reason.</p><h2 id="working-with-projects" tabindex="-1">Working with projects <a class="header-anchor" href="#working-with-projects" aria-label="Permalink to &quot;Working with projects&quot;">​</a></h2><p>Read <a href="./project-tutorial.html">project-tutorial</a>, it is very short. It is recommended to practice the following with an Aya project in VSCode, see <a href="./vscode-tutorial.html">vscode-tutorial</a>.</p><p>About modules:</p><ul><li><p>Aya module names are separated by <code>::</code>, not <code>.</code>.</p></li><li><p>Aya infers the module names automagically, using the same rule as of Haskell.</p></li><li><p>Aya imports (<code>import X</code>) are qualified by default, use <code>open import X</code> to unqualify. This is short for <code>import X</code> followed by <code>open X</code>.</p></li><li><p>Aya supports restricted import <code>open import X using (x)</code> (this only imports <code>x</code> from <code>X</code>) you may also use <code>open import X hiding (x)</code> to import everything except <code>x</code> from <code>X</code>.</p></li><li><p>Aya supports renamed import <code>open import X using (x as y)</code> and the meaning is obvious.</p></li><li><p>To re-export, use a <code>public open</code>.</p></li></ul><p>Ok, let&#39;s write some code!</p><h2 id="programming-in-aya" tabindex="-1">Programming in Aya <a class="header-anchor" href="#programming-in-aya" aria-label="Permalink to &quot;Programming in Aya&quot;">​</a></h2><p>Natural numbers. In Haskell:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Zero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Suc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span></span></code></pre></div><p>In Aya (we replaced the keyword <code>data</code> with <code>inductive</code> because we want to use it as a package name):</p>',20),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"inductive"),s(),a("a",{id:"Mian-Nat",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(" | "),a("a",{id:"Mian-Nat-zero",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-zero"},[a("span",{class:"Constructor"},"zero")]),s(" | "),a("a",{id:"Mian-Nat-suc",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")])]),s(`
`)],-1),h(`<p>We don&#39;t enforce capitalization of constructors. The constructors need to be qualified (like <code>Nat::zero</code>) to access. As you may expect, <code>Nat</code> automatically becomes a module, so we can use <code>open</code> and <code>public open</code> to unqualify the constructors.</p><p>Bonus: if you define a data type that <em>looks like</em> <code>Nat</code>, then you can use numeric literals.</p><p>Functions are defined with <code>def</code>, followed by pattern matching. Consider this natural number addition in Haskell (intentionally not called <code>+</code> to avoid name clash with Prelude):</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">(&lt;+&gt;)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Zero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;+&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;+&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Suc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;+&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">infixl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;+&gt;</span></span></code></pre></div><p>In Aya (remember the numeric literal thing?):</p>`,5),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"open"),s(),a("a",{href:"#Nat"},"Nat"),s(`
`),a("span",{class:"Keyword"},"def"),s(),a("span",{class:"Keyword"},"infixl"),s(),a("a",{id:"Mian-3c2b3e",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3c2b3e"},[a("span",{class:"Fn"},"<+>")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(`
| 0, `),a("a",{id:"v1753714541",class:"aya-hover","aya-hover-text":"Nat",href:"#v1753714541"},[a("span",{class:"LocalVar"},"n")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1753714541"},[a("span",{class:"LocalVar"},"n")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(),a("a",{id:"v871790326",class:"aya-hover","aya-hover-text":"Nat",href:"#v871790326"},[a("span",{class:"LocalVar"},"m")]),s(", "),a("a",{id:"v901205084",class:"aya-hover","aya-hover-text":"Nat",href:"#v901205084"},[a("span",{class:"LocalVar"},"n")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v871790326"},[a("span",{class:"LocalVar"},"m")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3c2b3e"},[a("span",{class:"Fn"},"<+>")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v901205084"},[a("span",{class:"LocalVar"},"n")]),s(")")]),s(`
`)],-1),h(`<p>There are plenty of differences. Let&#39;s go through them one by one.</p><p>The <code>infixl</code> declares <code>&lt;+&gt;</code> to be a left-associative infix operator. Other options include <code>infix</code>, <code>infixr</code>, <code>fixl</code>, and <code>fixr</code>. Without it, the function will work the same as normal function. Unlike Haskell, we do not distinguish &quot;operator&quot; names and &quot;function&quot; names.</p><p>We do not use a number to denote precedence, but a partial order. This allows arbitrary insertion of new precedence level into previously defined ones. Say you want <code>&lt;+&gt;</code> to have a lower precedence than <code>&lt;*&gt;</code>, you can do:</p><pre class="Aya"><code><span class="Keyword">def</span> <span class="Keyword">infixl</span> &lt;+&gt; Nat Nat : Nat
<span class="Comment">/// .... omitted</span>
<span class="Keyword">looser</span> &lt;*&gt;</code>
</pre><p>You also have <code>tighter</code>, with the obvious meaning.</p><p>The parameters and the return type are separated using <code>:</code>. The parameter types can be written directly, without <code>-&gt;</code>. Aya allow naming the parameters like this:</p><pre class="Aya"><code><span class="Keyword">def</span> oh (x : Nat) : Nat</code>
</pre><p>These names can be used for one-linear function bodies:</p>`,8),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"def"),s(),a("a",{id:"Mian-oh",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-oh"},[a("span",{class:"Fn"},"oh")]),s(" ("),a("a",{id:"v110651474",class:"aya-hover","aya-hover-text":"Nat",href:"#v110651474"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(") : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v110651474"},[a("span",{class:"LocalVar"},"x")])]),s(`
`)],-1),h(`<p>Aya supports a painless version of the section syntax, where the top-level does not need parentheses. See the following REPL output (the underscored names are internally generated variable names. If you have an idea on how to make them better, open an issue and let&#39;s discuss!).</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; 1 &lt;+&gt;</span></span>
<span class="line"><span>suc</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&gt; &lt;+&gt; 1</span></span>
<span class="line"><span>λ _7 ⇒ _7 &lt;+&gt; 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&gt; 1 &lt;+&gt; 1</span></span>
<span class="line"><span>suc 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&gt; 2 &lt;+&gt;</span></span>
<span class="line"><span>λ _5 ⇒ suc (suc _5)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&gt; &lt;+&gt; 2</span></span>
<span class="line"><span>λ _7 ⇒ _7 &lt;+&gt; 2</span></span></code></pre></div><p>When we only need to pattern match on a subset of the parameters, we can use the <code>elim</code> keyword:</p>`,3),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"example"),s(),a("span",{class:"Keyword"},"def"),s(),a("span",{class:"Keyword"},"infixl"),s(),a("a",{id:"Mian-3aNoExport-5b2b5d",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3aNoExport-5b2b5d"},[a("span",{class:"Fn"},"[+]")]),s(" ("),a("a",{id:"v170949260",class:"aya-hover","aya-hover-text":"Nat",href:"#v170949260"},[a("span",{class:"LocalVar"},"a")]),s(),a("a",{id:"v1845623216",class:"aya-hover","aya-hover-text":"Nat",href:"#v1845623216"},[a("span",{class:"LocalVar"},"n")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(") : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(),a("span",{class:"Keyword"},"elim"),s(),a("a",{href:"#v170949260"},[a("span",{class:"LocalVar"},"a")]),s(`
| 0 ⇒ `),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1845623216"},[a("span",{class:"LocalVar"},"n")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(),a("a",{id:"v965586344",class:"aya-hover","aya-hover-text":"Nat",href:"#v965586344"},[a("span",{class:"LocalVar"},"m")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v965586344"},[a("span",{class:"LocalVar"},"m")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3aNoExport-5b2b5d"},[a("span",{class:"Fn"},"[+]")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1845623216"},[a("span",{class:"LocalVar"},"n")]),s(")")]),s(`
`)],-1),h(`<h2 id="type-level-programming" tabindex="-1">Type-level programming <a class="header-anchor" href="#type-level-programming" aria-label="Permalink to &quot;Type-level programming&quot;">​</a></h2><p>In Haskell:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span></code></pre></div><p>In Aya:</p>`,4),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"def"),s(),a("a",{id:"Mian-id",class:"aya-hover","aya-hover-text":"A",href:"#Mian-id"},[a("span",{class:"Fn"},"id")]),s(" {"),a("a",{id:"v1337866219",class:"aya-hover","aya-hover-text":"Type 0",href:"#v1337866219"},[a("span",{class:"LocalVar"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s("} ("),a("a",{id:"v313082880",class:"aya-hover","aya-hover-text":"A",href:"#v313082880"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1337866219"},[a("span",{class:"LocalVar"},"A")]),s(") ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"A",href:"#v313082880"},[a("span",{class:"LocalVar"},"x")])]),s(`
`)],-1),h("<p>Observations:</p><ul><li><p>Type parameters have to be explicitly qualified using curly braces.</p></li><li><p>Curly braces denote parameters that are omitted (and will be inferred by type checker) in the pattern matching and invocations. So, parentheses denote parameters that are <i>not</i> omitted.</p></li><li><p>Apart from <code>Type</code>, we also have <code>Set</code>, and <code>ISet</code>. For now, don&#39;t use the others.</p></li></ul><p>Type constructors are like <code>{F : Type -&gt; Type}</code> (and yes, the <code>-&gt;</code> denotes function types, works for both values and types), very obvious. Definition of <code>Maybe</code> in Aya:</p>",3),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"open"),s(),a("span",{class:"Keyword"},"inductive"),s(),a("a",{id:"Mian-Maybe",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Maybe"},[a("span",{class:"Data"},"Maybe")]),s(" ("),a("a",{id:"v193178046",class:"aya-hover","aya-hover-text":"Type 0",href:"#v193178046"},[a("span",{class:"LocalVar"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s(`)
| `),a("a",{id:"Mian-Maybe-nothing",class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-nothing"},[a("span",{class:"Constructor"},"nothing")]),s(`
| `),a("a",{id:"Mian-Maybe-just",class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-just"},[a("span",{class:"Constructor"},"just")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v193178046"},[a("span",{class:"LocalVar"},"A")])]),s(`
`)],-1),a("p",null,[s("Here, "),a("code",null,"(A : Type)"),s(" is an explicit parameter, because you write "),a("code",null,"Maybe Nat"),s(", not just "),a("code",null,"Maybe"),s(".")],-1),a("p",null,[s("There is a way to automagically insert the implicit parameters -- the "),a("code",null,"variable"),s(" keyword.")],-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"variable"),s(),a("a",{id:"v764419760",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s(`

`),a("span",{class:"Comment"},"// Now, since you are using A, so Aya inserts {A : Type}"),s(`
`),a("span",{class:"Keyword"},"example"),s(),a("span",{class:"Keyword"},"def"),s(),a("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+V2FybmluZzogVGhlIG5hbWUgYGlkYCBzaGFkb3dzIGEgcHJldmlvdXMgbG9jYWwgZGVmaW5pdGlvbiBmcm9tIG91dGVyIHNjb3BlPC9jb2RlPgo8L3ByZT4K"},[a("span",{class:"Warning"},[a("a",{id:"Mian-3aNoExport-id",class:"aya-hover","aya-hover-text":"A",href:"#Mian-3aNoExport-id"},[a("span",{class:"Fn"},"id")])])]),s(" ("),a("a",{id:"v1826334428",class:"aya-hover","aya-hover-text":"A",href:"#v1826334428"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(") ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"A",href:"#v1826334428"},[a("span",{class:"LocalVar"},"x")])]),s(`
`)],-1),a("p",null,"Aya supports type aliases as functions. For example, we may define the type of binary operators as a function:",-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"def"),s(),a("a",{id:"Mian-BinOp",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-BinOp"},[a("span",{class:"Fn"},"BinOp")]),s(" ("),a("a",{id:"v51152513",class:"aya-hover","aya-hover-text":"Type 0",href:"#v51152513"},[a("span",{class:"LocalVar"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s(") ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v51152513"},[a("span",{class:"LocalVar"},"A")]),s(" → "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v51152513"},[a("span",{class:"LocalVar"},"A")]),s(" → "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v51152513"},[a("span",{class:"LocalVar"},"A")])]),s(`
`)],-1),a("p",null,[s("Then, we can define "),a("code",null,"<+>"),s(" as:")],-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"example"),s(),a("span",{class:"Keyword"},"def"),s(),a("span",{class:"Keyword"},"infixl"),s(),a("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+V2FybmluZzogVGhlIG5hbWUgYDwrPmAgc2hhZG93cyBhIHByZXZpb3VzIGxvY2FsIGRlZmluaXRpb24gZnJvbSBvdXRlciBzY29wZTwvY29kZT4KPC9wcmU+Cg=="},[a("span",{class:"Warning"},[a("a",{id:"Mian-3aNoExport-3c2b3e",class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3aNoExport-3c2b3e"},[a("span",{class:"Fn"},"<+>")])])]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-BinOp"},[a("span",{class:"Fn"},"BinOp")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(`
| 0, `),a("a",{id:"v1789268516",class:"aya-hover","aya-hover-text":"Nat",href:"#v1789268516"},[a("span",{class:"LocalVar"},"n")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1789268516"},[a("span",{class:"LocalVar"},"n")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(),a("a",{id:"v817686795",class:"aya-hover","aya-hover-text":"Nat",href:"#v817686795"},[a("span",{class:"LocalVar"},"m")]),s(", "),a("a",{id:"v1047478056",class:"aya-hover","aya-hover-text":"Nat",href:"#v1047478056"},[a("span",{class:"LocalVar"},"n")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v817686795"},[a("span",{class:"LocalVar"},"m")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3aNoExport-3c2b3e"},[a("span",{class:"Fn"},"<+>")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1047478056"},[a("span",{class:"LocalVar"},"n")]),s(")")]),s(`
`)],-1),a("h2",{id:"type-families",tabindex:"-1"},[s("Type families "),a("a",{class:"header-anchor",href:"#type-families","aria-label":'Permalink to "Type families"'},"​")],-1),a("p",null,[s("In Aya, type families are functions. Consider the following code (they are using the "),a("code",null,"variable A"),s(" defined above):")],-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Comment"},"// Unit type"),s(`
`),a("span",{class:"Keyword"},"open"),s(),a("span",{class:"Keyword"},"inductive"),s(),a("a",{id:"Mian-Unit",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Unit"},[a("span",{class:"Data"},"Unit")]),s(" | "),a("a",{id:"Mian-Unit-unit",class:"aya-hover","aya-hover-text":"Unit",href:"#Mian-Unit-unit"},[a("span",{class:"Constructor"},"unit")]),s(`

`),a("span",{class:"Comment"},"// A type family"),s(`
`),a("span",{class:"Keyword"},"def"),s(),a("a",{id:"Mian-FromJust",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-FromJust"},[a("span",{class:"Fn"},"FromJust")]),s(" ("),a("a",{id:"v110053477",class:"aya-hover","aya-hover-text":"Maybe A",href:"#v110053477"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Maybe"},[a("span",{class:"Data"},"Maybe")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(") : "),a("span",{class:"Keyword"},"Type"),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-just"},[a("span",{class:"Constructor"},"just")]),s(),a("a",{id:"v1320105604",class:"aya-hover","aya-hover-text":"A",href:"#v1320105604"},[a("span",{class:"LocalVar"},"a")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-nothing"},[a("span",{class:"Constructor"},"nothing")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Unit"},[a("span",{class:"Data"},"Unit")]),s(`

`),a("span",{class:"Comment"},"// A function that uses the type family"),s(`
`),a("span",{class:"Keyword"},"def"),s(),a("a",{id:"Mian-fromJust",class:"aya-hover","aya-hover-text":"FromJust x",href:"#Mian-fromJust"},[a("span",{class:"Fn"},"fromJust")]),s(" ("),a("a",{id:"v1534755892",class:"aya-hover","aya-hover-text":"Maybe A",href:"#v1534755892"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Maybe"},[a("span",{class:"Data"},"Maybe")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(") : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-FromJust"},[a("span",{class:"Fn"},"FromJust")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#v1534755892"},[a("span",{class:"LocalVar"},"x")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-just"},[a("span",{class:"Constructor"},"just")]),s(),a("a",{id:"v1142347343",class:"aya-hover","aya-hover-text":"A",href:"#v1142347343"},[a("span",{class:"LocalVar"},"a")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"A",href:"#v1142347343"},[a("span",{class:"LocalVar"},"a")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#Mian-Maybe-nothing"},[a("span",{class:"Constructor"},"nothing")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Unit",href:"#Mian-Unit-unit"},[a("span",{class:"Constructor"},"unit")])]),s(`
`)],-1),a("p",null,[s("And "),a("code",null,"fromJust (just a)"),s(" will evaluate to "),a("code",null,"a"),s(". In Haskell, you need to use some language extensions alongside some scary keywords. These functions are available in constructors, too:")],-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"inductive"),s(),a("a",{id:"Mian-Example",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Example"},[a("span",{class:"Data"},"Example")]),s(" ("),a("a",{id:"v808417649",class:"aya-hover","aya-hover-text":"Type 0",href:"#v808417649"},[a("span",{class:"LocalVar"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s(`)
| `),a("a",{id:"Mian-Example-cons",class:"aya-hover","aya-hover-text":"Example A",href:"#Mian-Example-cons"},[a("span",{class:"Constructor"},"cons")]),s(" ("),a("a",{id:"v858204589",class:"aya-hover","aya-hover-text":"Maybe A",href:"#v858204589"},[a("span",{class:"LocalVar"},"x")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Maybe"},[a("span",{class:"Data"},"Maybe")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v808417649"},[a("span",{class:"LocalVar"},"A")]),s(") ("),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-FromJust"},[a("span",{class:"Fn"},"FromJust")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Maybe A",href:"#v858204589"},[a("span",{class:"LocalVar"},"x")]),s(")")]),s(`
`)],-1),h(`<p>It is recommended to play with it in the REPL to get a feel of it.</p><p>There is a famous example of dependent types in Haskell -- the sized vector type:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{-# </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LANGUAGE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GADTs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> #-}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{-# </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LANGUAGE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> DataKinds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> #-}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- Maybe you need more, I don&#39;t remember exactly</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Nat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Zero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Suc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">infixr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :&lt;</span></span></code></pre></div><p>In Aya, we have a better syntax:</p>`,4),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"open"),s(),a("span",{class:"Keyword"},"inductive"),s(),a("a",{id:"Mian-Vec",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[a("span",{class:"Data"},"Vec")]),s(" ("),a("a",{id:"v156710276",class:"aya-hover","aya-hover-text":"Nat",href:"#v156710276"},[a("span",{class:"LocalVar"},"n")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(") ("),a("a",{id:"v53940034",class:"aya-hover","aya-hover-text":"Type 0",href:"#v53940034"},[a("span",{class:"LocalVar"},"A")]),s(" : "),a("span",{class:"Keyword"},"Type"),s(`)
| 0, `),a("a",{id:"v1616359099",class:"aya-hover","aya-hover-text":"Type 0",href:"#v1616359099"},[a("span",{class:"LocalVar"},"A")]),s(" ⇒ "),a("a",{id:"Mian-Vec-nil",class:"aya-hover","aya-hover-text":"Vec 0 A",href:"#Mian-Vec-nil"},[a("span",{class:"Constructor"},"nil")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-Nat-suc"},[a("span",{class:"Constructor"},"suc")]),s(),a("a",{id:"v2106165633",class:"aya-hover","aya-hover-text":"Nat",href:"#v2106165633"},[a("span",{class:"LocalVar"},"n")]),s(", "),a("a",{id:"v1221991240",class:"aya-hover","aya-hover-text":"Type 0",href:"#v1221991240"},[a("span",{class:"LocalVar"},"A")]),s(" ⇒ "),a("span",{class:"Keyword"},"infixr"),s(),a("a",{id:"Mian-Vec-3a3c",class:"aya-hover","aya-hover-text":"Vec (suc n) A",href:"#Mian-Vec-3a3c"},[a("span",{class:"Constructor"},":<")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1221991240"},[a("span",{class:"LocalVar"},"A")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[a("span",{class:"Data"},"Vec")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v2106165633"},[a("span",{class:"LocalVar"},"n")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1221991240"},[a("span",{class:"LocalVar"},"A")]),s(")")]),s(`
`)],-1),a("p",null,[s("The "),a("code",{class:"Aya"},[a("a",{href:"#Mian-Vec-3a3c"},[a("span",{class:"Constructor"},":<")])]),s(" constructor is defined as a right-associative infix operator. And yes, you can define like vector append painlessly:")],-1),a("pre",{class:"Aya"},[s(""),a("code",null,[a("span",{class:"Keyword"},"variable"),s(),a("a",{id:"v1094523823",href:"#v1094523823"},[a("span",{class:"Generalized"},"m")]),s(),a("a",{id:"v1823409783",href:"#v1823409783"},[a("span",{class:"Generalized"},"n")]),s(" : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[a("span",{class:"Data"},"Nat")]),s(`

`),a("span",{class:"Keyword"},"def"),s(),a("span",{class:"Keyword"},"infixr"),s(),a("a",{id:"Mian-2b2b",class:"aya-hover","aya-hover-text":"Vec (n <+> m) A",href:"#Mian-2b2b"},[a("span",{class:"Fn"},"++")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[a("span",{class:"Data"},"Vec")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1823409783"},[a("span",{class:"Generalized"},"n")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(") ("),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[a("span",{class:"Data"},"Vec")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1094523823"},[a("span",{class:"Generalized"},"m")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(") : "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[a("span",{class:"Data"},"Vec")]),s(" ("),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1823409783"},[a("span",{class:"Generalized"},"n")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-3c2b3e"},[a("span",{class:"Fn"},"<+>")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#v1094523823"},[a("span",{class:"Generalized"},"m")]),s(") "),a("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v764419760"},[a("span",{class:"Generalized"},"A")]),s(`
| `),a("a",{class:"aya-hover","aya-hover-text":"Vec 0 A",href:"#Mian-Vec-nil"},[a("span",{class:"Constructor"},"nil")]),s(", "),a("a",{id:"v1090541608",class:"aya-hover","aya-hover-text":"Vec m A",href:"#v1090541608"},[a("span",{class:"LocalVar"},"ys")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"Vec m A",href:"#v1090541608"},[a("span",{class:"LocalVar"},"ys")]),s(`
| `),a("a",{id:"v34871826",class:"aya-hover","aya-hover-text":"A",href:"#v34871826"},[a("span",{class:"LocalVar"},"x")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec (suc n) A",href:"#Mian-Vec-3a3c"},[a("span",{class:"Constructor"},":<")]),s(),a("a",{id:"v1100399456",class:"aya-hover","aya-hover-text":"Vec n A",href:"#v1100399456"},[a("span",{class:"LocalVar"},"xs")]),s(", "),a("a",{id:"v68326648",class:"aya-hover","aya-hover-text":"Vec m A",href:"#v68326648"},[a("span",{class:"LocalVar"},"ys")]),s(" ⇒ "),a("a",{class:"aya-hover","aya-hover-text":"A",href:"#v34871826"},[a("span",{class:"LocalVar"},"x")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec (suc (?n A x xs ys n m)) (?A A x xs ys n m)",href:"#Mian-Vec-3a3c"},[a("span",{class:"Constructor"},":<")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec n A",href:"#v1100399456"},[a("span",{class:"LocalVar"},"xs")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec (?n A x xs ys n m <+> ?m A x xs ys n m) (?A A x xs ys n m)",href:"#Mian-2b2b"},[a("span",{class:"Fn"},"++")]),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec m A",href:"#v68326648"},[a("span",{class:"LocalVar"},"ys")]),s(`
`),a("span",{class:"Keyword"},"tighter"),s(),a("a",{class:"aya-hover","aya-hover-text":"Vec (suc n) A",href:"#Mian-Vec-3a3c"},[a("span",{class:"Constructor"},":<")])]),s(`
`)],-1),h(`<p>Imagine how much work this is in Haskell.</p><h2 id="overlapping-patterns" tabindex="-1">Overlapping patterns <a class="header-anchor" href="#overlapping-patterns" aria-label="Permalink to &quot;Overlapping patterns&quot;">​</a></h2><p>There is one more bonus: in Aya, you may modify the definition of <code>&lt;+&gt;</code> to be:</p><pre class="Aya"><code><span class="Keyword">overlap</span> <span class="Keyword">def</span> <span class="Keyword">infixl</span> &lt;+&gt; Nat Nat : Nat
| 0, n ⇒ n
| n, 0 ⇒ n
| suc m, n ⇒ suc (m &lt;+&gt; n)</code>
</pre><p>It says we not only compute <code>0 + n = n</code>, but when the first parameter is neither <code>0</code> nor <code>suc</code>, we may take a look at the second parameter and seek for other potential computations. This is completely useless at runtime, but very good for type checking. For instance, we may want a <code class="Aya"><a href="#Mian-Vec"><span class="Data">Vec</span></a></code> of size <code>n</code>, and what we have is some <code class="Aya"><a href="#Mian-Vec"><span class="Data">Vec</span></a></code> of size <code>n + 0</code>. Then having <code>n + 0</code> to directly reduce to <code>n</code> is very useful, otherwise we will need to write a conversion function that does nothing but changes the type, or use <code>unsafeCoerce</code>.</p><p>With <code>n + 0 = n</code> judgmentally, we now have more possibilities. For instance, we can make <code>xs ++ nil = xs</code>. This involves in two steps: we first turni <code>++</code> into a <code>overlap def</code>, then we add the following clause to <code>++</code>:</p><pre class="Aya"><code>| xs, nil ⇒ xs</code>
</pre><p>This makes <code>++</code> compute on more cases too.</p><p>For more information about this feature, checkout the <a href="./prover-tutorial.html">tutorial for proof assistant users</a>.</p>`,9)]))}const _=w(M,[["render",V]]);export{C as __pageData,_ as default};
