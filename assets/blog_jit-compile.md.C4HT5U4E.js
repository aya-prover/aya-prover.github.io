import{_ as I,c as x,o as M,a2 as p,j as e,a}from"./chunks/framework.BV7BAn2o.js";const A={mounted(){const m=new Map;function d(l){const s=l.querySelectorAll("a[href]");for(const t of s){const n=t.href,h=m.get(n)??new Set;h.add(t),m.set(n,h)}for(const t of s)t.onmouseover=function(){for(const n of m.get(this.href))n.classList.add("hover-highlight")},t.onmouseout=function(){for(const n of m.get(this.href))n.classList.remove("hover-highlight")}}function v(l){return decodeURIComponent(atob(l).split("").map(function(s){return"%"+("00"+s.charCodeAt(0).toString(16)).slice(-2)}).join(""))}const u=(l=>{const s={};return(...t)=>{const n=JSON.stringify(t);return s[n]=s[n]||l(...t)}})(v);class f{constructor(){this.list=[]}dismiss(s){s&&(s.remove(),this.list=this.list.filter(t=>t!==s))}dismissIfNotUsed(s){s&&(s.markedForDismissal=!0,setTimeout(()=>{!s.userIsThinking&&this.allowAutoDismissal(s)&&this.dismiss(s)},1e3))}allowAutoDismissal(s){return s.markedForDismissal&&!s.userClicked}fireAutoDismissalFor(s){let t=this.list.find(n=>n.userCreatedFrom===s);this.dismissIfNotUsed(t)}createHoverFor(s,t,n){let h=this.list.find(o=>o.userCreatedFrom===s);if(h&&h.userClicked)return h;let b=[];const g=this.list.filter(o=>{if(this.allowAutoDismissal(o))return b.push(o),!1;const i=o.userCreatedFrom,y=s;let c=y;for(;c;){if(c===i)return!0;c=c.parentElement}for(c=i;c;){if(c===y)return!0;c=c.parentElement}return!1});b.forEach(o=>this.dismiss(o));let r=document.createElement("div");r.userCreatedFrom=s,r.innerHTML="<span id='AyaTooltipPopupClose'>&times;</span>"+u(t),r.classList.add("AyaTooltipPopup"),d(r);let w=this;if(r.handleEvent=function(o){if(o.type==="click"){this.userClicked=!0,this.markedForDismissal=!1;let i=this.children[0];if(!i)return;let y=this;i.style.visibility="visible",i.addEventListener("click",c=>w.dismiss(y))}o.type==="mouseover"&&(this.userIsThinking=!0),o.type==="mouseout"&&(this.userIsThinking=!1,w.dismissIfNotUsed(this))},r.addEventListener("click",r),r.addEventListener("mouseover",r),r.addEventListener("mouseout",r),n.appendChild(r),r.style.left=`${s.offsetLeft}px`,g.length===0){const o=s.getBoundingClientRect(),i=r.getBoundingClientRect();o.bottom+i.height+30>window.innerHeight?r.style.top=`calc(${s.offsetTop-i.height+8}px - 3em)`:r.style.top=`${s.offsetTop+s.offsetHeight+8}px`}else{const o=Math.max(...g.map(i=>i.offsetTop+i.offsetHeight));r.style.top=`${o+8}px`}return this.list.push(r),r}}let T=new f;function V(l){return function(){let s=this;const t=s.getAttribute("data-tooltip-text");t&&(l?T.createHoverFor(s,t,document.body):T.fireAutoDismissalFor(s))}}d(document);{let l=document.getElementsByClassName("aya-tooltip");for(let s=0;s<l.length;s++){let t=l[s];t.hasAttribute("data-tooltip-text")&&(t.onmouseover=V(!0),t.onmouseout=V(!1))}}}},D=JSON.parse('{"title":"JJH (JVM JIT HOAS) compilation for Aya","description":"","frontmatter":{"lastUpdated":"2025-02-13T21:04:08.000Z"},"headers":[],"relativePath":"blog/jit-compile.md","filePath":"blog/jit-compile.md","lastUpdated":1739480648000}');function j(m,d,v,C,u,f){return M(),x("div",null,d[0]||(d[0]=[p('<h1 id="jjh-jvm-jit-hoas-compilation-for-aya" tabindex="-1">JJH (JVM JIT HOAS) compilation for Aya <a class="header-anchor" href="#jjh-jvm-jit-hoas-compilation-for-aya" aria-label="Permalink to &quot;JJH \\(JVM JIT HOAS\\) compilation for Aya&quot;">​</a></h1><p>Update 2025-02-12: I gave a <a href="https://www.youtube.com/watch?v=lvwygACgJFk&amp;t" target="_blank" rel="noreferrer">PLunch talk</a> about this.</p><p>In this post I&#39;d like to introduce the <em>JJH</em> compilation architecture of the new Aya type checker, which is based on the JIT (Just-In-Time) compilation on the Java VM for closures implemented using HOAS (Higher-Order Abstract Syntax). I&#39;ll explain.</p><h2 id="pros-and-cons-of-hoas" tabindex="-1">Pros and Cons of HOAS <a class="header-anchor" href="#pros-and-cons-of-hoas" aria-label="Permalink to &quot;Pros and Cons of HOAS&quot;">​</a></h2><p>When implementing an interpreter, we have a meta-level language that we use to write the interpreter itself, and the object level language which we interpret. In case of higher-order languages, the object level language will have lambda expressions, and the representation of closures in the meta level language will be very important for the performance of the interpreter. To implement closures, we need to represent binders and variable references, and implement a substitution operation.</p><p>This is a relatively well-known and well-studied problem, and there are <a href="https://jesper.sikanda.be/posts/1001-syntax-representations.html" target="_blank" rel="noreferrer">several ways</a> (allow me to delegate the introduction of this subject to Jesper&#39;s blog) to implement it. In the context of Aya we are interested in the locally nameless (LN) representation and HOAS, and I&#39;ll assume brief familiarity with these concepts.</p><p>Consider STLC, the syntax can be defined as the following type, assuming an appropriate type <code class="Aya"><a href="#Mian-UID"><span class="Data">UID</span></a></code>:</p>',7),e("pre",{class:"Aya"},[a(""),e("code",null,[e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-TermV1",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV1"},[e("span",{class:"Data"},"TermV1")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-TermV1-bound",class:"aya-hover","aya-hover-text":"TermV1",href:"#Mian-TermV1-bound"},[e("span",{class:"Constructor"},"bound")]),a(" ("),e("a",{id:"v1530446316",class:"aya-hover","aya-hover-text":"Nat",href:"#v1530446316"},[e("span",{class:"LocalVar"},"deBruijnIndex")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[e("span",{class:"Data"},"Nat")]),a(`)
| `),e("a",{id:"Mian-TermV1-free",class:"aya-hover","aya-hover-text":"TermV1",href:"#Mian-TermV1-free"},[e("span",{class:"Constructor"},"free")]),a(" ("),e("a",{id:"v865059288",class:"aya-hover","aya-hover-text":"UID",href:"#v865059288"},[e("span",{class:"LocalVar"},"name")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-UID"},[e("span",{class:"Data"},"UID")]),a(`)
| `),e("a",{id:"Mian-TermV1-lam",class:"aya-hover","aya-hover-text":"TermV1",href:"#Mian-TermV1-lam"},[e("span",{class:"Constructor"},"lam")]),a(" ("),e("a",{id:"v1193471756",class:"aya-hover","aya-hover-text":"TermV1",href:"#v1193471756"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV1"},[e("span",{class:"Data"},"TermV1")]),a(`)
| `),e("a",{id:"Mian-TermV1-app",class:"aya-hover","aya-hover-text":"TermV1",href:"#Mian-TermV1-app"},[e("span",{class:"Constructor"},"app")]),a(" ("),e("a",{id:"v1222768327",class:"aya-hover","aya-hover-text":"TermV1",href:"#v1222768327"},[e("span",{class:"LocalVar"},"fun")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV1"},[e("span",{class:"Data"},"TermV1")]),a(") ("),e("a",{id:"v1439394198",class:"aya-hover","aya-hover-text":"TermV1",href:"#v1439394198"},[e("span",{class:"LocalVar"},"arg")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV1"},[e("span",{class:"Data"},"TermV1")]),a(")")]),a(`
`)],-1),p('<p>The important constructor to consider here is <code class="Aya"><a href="#Mian-TermV1-lam"><span class="Constructor">lam</span></a></code>, whose body will allow the use of bound variables. If a term is completely outside a <code class="Aya"><a href="#Mian-TermV1-lam"><span class="Constructor">lam</span></a></code>, it will make no sense. The substitution operation is only performed on bodies of lambdas, by replacing a De Bruijn index with a term. It might make sense to use types to enforce that:</p>',1),e("pre",{class:"Aya"},[a(""),e("code",null,[e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-ClosureV2",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV2"},[e("span",{class:"Data"},"ClosureV2")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-ClosureV2-mkClosure",class:"aya-hover","aya-hover-text":"ClosureV2",href:"#Mian-ClosureV2-mkClosure"},[e("span",{class:"Constructor"},"mkClosure")]),a(" ("),e("a",{id:"v1208825205",class:"aya-hover","aya-hover-text":"TermV2",href:"#v1208825205"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(`)

`),e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-TermV2",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-TermV2-bound",class:"aya-hover","aya-hover-text":"TermV2",href:"#Mian-TermV2-bound"},[e("span",{class:"Constructor"},"bound")]),a(" ("),e("a",{id:"v253601149",class:"aya-hover","aya-hover-text":"Nat",href:"#v253601149"},[e("span",{class:"LocalVar"},"deBruijnIndex")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[e("span",{class:"Data"},"Nat")]),a(`)
| `),e("a",{id:"Mian-TermV2-free",class:"aya-hover","aya-hover-text":"TermV2",href:"#Mian-TermV2-free"},[e("span",{class:"Constructor"},"free")]),a(" ("),e("a",{id:"v26540753",class:"aya-hover","aya-hover-text":"UID",href:"#v26540753"},[e("span",{class:"LocalVar"},"name")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-UID"},[e("span",{class:"Data"},"UID")]),a(`)
| `),e("a",{id:"Mian-TermV2-lam",class:"aya-hover","aya-hover-text":"TermV2",href:"#Mian-TermV2-lam"},[e("span",{class:"Constructor"},"lam")]),a(" ("),e("a",{id:"v648786246",class:"aya-hover","aya-hover-text":"ClosureV2",href:"#v648786246"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV2"},[e("span",{class:"Data"},"ClosureV2")]),a(`)
| `),e("a",{id:"Mian-TermV2-app",class:"aya-hover","aya-hover-text":"TermV2",href:"#Mian-TermV2-app"},[e("span",{class:"Constructor"},"app")]),a(" ("),e("a",{id:"v120360571",class:"aya-hover","aya-hover-text":"TermV2",href:"#v120360571"},[e("span",{class:"LocalVar"},"fun")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(") ("),e("a",{id:"v1710814638",class:"aya-hover","aya-hover-text":"TermV2",href:"#v1710814638"},[e("span",{class:"LocalVar"},"arg")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(`)

`),e("span",{class:"Keyword"},"def"),a(),e("a",{id:"Mian-applyV2",class:"aya-hover","aya-hover-text":"TermV2",href:"#Mian-applyV2"},[e("span",{class:"Fn"},"applyV2")]),a(" ("),e("a",{id:"v1125964210",class:"aya-hover","aya-hover-text":"ClosureV2",href:"#v1125964210"},[e("span",{class:"LocalVar"},"t")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV2"},[e("span",{class:"Data"},"ClosureV2")]),a(") ("),e("a",{id:"v944140566",class:"aya-hover","aya-hover-text":"TermV2",href:"#v944140566"},[e("span",{class:"LocalVar"},"s")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(") : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV2"},[e("span",{class:"Data"},"TermV2")]),a(" ⇒ "),e("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+R29hbDogR29hbCBvZiB0eXBlCiAgICAgICAgPGEgaHJlZj0iI01pYW4tVGVybVYyIj48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVYyPC9zcGFuPjwvYT4KICAgICAgICAoTm9ybWFsaXplZDogPGEgaHJlZj0iI01pYW4tVGVybVYyIj48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVYyPC9zcGFuPjwvYT4pCiAgICAgIENvbnRleHQ6CiAgICAgICAgPGEgaHJlZj0iI3YxMTI1OTY0MjEwIj48c3BhbiBjbGFzcz0iTG9jYWxWYXIiPnQ8L3NwYW4+PC9hPiA6IDxhIGhyZWY9IiNNaWFuLUNsb3N1cmVWMiI+PHNwYW4gY2xhc3M9IkRhdGEiPkNsb3N1cmVWMjwvc3Bhbj48L2E+CiAgICAgICAgPGEgaHJlZj0iI3Y5NDQxNDA1NjYiPjxzcGFuIGNsYXNzPSJMb2NhbFZhciI+czwvc3Bhbj48L2E+IDogPGEgaHJlZj0iI01pYW4tVGVybVYyIj48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVYyPC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="},[e("span",{class:"Goal"},[e("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPj88YSBocmVmPSIjdjEwNzIzNzczMDYiPl84PC9hPiA8YSBocmVmPSIjdjExMjU5NjQyMTAiPjxzcGFuIGNsYXNzPSJMb2NhbFZhciI+dDwvc3Bhbj48L2E+IDxhIGhyZWY9IiN2OTQ0MTQwNTY2Ij48c3BhbiBjbGFzcz0iTG9jYWxWYXIiPnM8L3NwYW4+PC9hPjwvc3Bhbj48L2NvZGU+CjwvcHJlPgo="},"{??}")])])]),a(`
`)],-1),p('<p>By designing the term structure like this, it is clear that which terms are meant to be applied. In the implementation of <code class="Aya"><a href="#Mian-applyV2"><span class="Fn">applyV2</span></a></code>, we traverse <code>t</code> and build a new term based on <code>t</code>.</p><p>HOAS implements closures and substitution differently, which instead of traversing and replacing <code class="Aya"><a href="#Mian-TermV2-bound"><span class="Constructor">bound</span></a></code> with a term, it constructs terms directly by using a function in the meta-level language (the definition below is accepted because Aya doesn&#39;t yet have a positivity checker):</p>',2),e("pre",{class:"Aya"},[a(""),e("code",null,[e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-ClosureV3",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV3"},[e("span",{class:"Data"},"ClosureV3")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-ClosureV3-mkClosure",class:"aya-hover","aya-hover-text":"ClosureV3",href:"#Mian-ClosureV3-mkClosure"},[e("span",{class:"Constructor"},"mkClosure")]),a(" ("),e("a",{id:"v1795816257",class:"aya-hover","aya-hover-text":"TermV3 → TermV3",href:"#v1795816257"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV3"},[e("span",{class:"Data"},"TermV3")]),a(" → "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV3"},[e("span",{class:"Data"},"TermV3")]),a(`)

`),e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-TermV3",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV3"},[e("span",{class:"Data"},"TermV3")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-TermV3-free",class:"aya-hover","aya-hover-text":"TermV3",href:"#Mian-TermV3-free"},[e("span",{class:"Constructor"},"free")]),a(" ("),e("a",{id:"v1649320501",class:"aya-hover","aya-hover-text":"UID",href:"#v1649320501"},[e("span",{class:"LocalVar"},"name")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-UID"},[e("span",{class:"Data"},"UID")]),a(`)
| `),e("a",{id:"Mian-TermV3-lam",class:"aya-hover","aya-hover-text":"TermV3",href:"#Mian-TermV3-lam"},[e("span",{class:"Constructor"},"lam")]),a(" ("),e("a",{id:"v959629210",class:"aya-hover","aya-hover-text":"ClosureV3",href:"#v959629210"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV3"},[e("span",{class:"Data"},"ClosureV3")]),a(`)
| `),e("a",{id:"Mian-TermV3-app",class:"aya-hover","aya-hover-text":"TermV3",href:"#Mian-TermV3-app"},[e("span",{class:"Constructor"},"app")]),a(" ("),e("a",{id:"v125994398",class:"aya-hover","aya-hover-text":"TermV3",href:"#v125994398"},[e("span",{class:"LocalVar"},"fun")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV3"},[e("span",{class:"Data"},"TermV3")]),a(") ("),e("a",{id:"v603305436",class:"aya-hover","aya-hover-text":"TermV3",href:"#v603305436"},[e("span",{class:"LocalVar"},"arg")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV3"},[e("span",{class:"Data"},"TermV3")]),a(")")]),a(`
`)],-1),p(`<p>Intuitively, HOAS requires no term traversal to produce the result of substitution, so it must be a lot faster. In reality, this is true, but only if these meta-level functions are known at the compile time of the interpreter -- an assumption that is usually false. In practice, we parse the AST from a string, resolve the names in it, desugar it, and then type check it before producing a term that can be interpreted. This means we do not know the body of the closure at the compile time. Also, the terms during type checking are <em>mutable</em>:</p><ol><li><p>We have <i>local type inference</i> (also known as <i>solving metavariables</i>), which involves in creating unknown terms and replace them with known terms later. This means we also need to <i>traverse</i> and <i>mutate</i> the terms, which is unrealistic for HOAS (this can be done in a very slow way).</p></li><li><p>We support type checking <i>recursive</i> functions. When checking the body of a recursive function, the recursive calls cannot be unfolded because the body is not yet constructed, and before termination check we cannot really know if unfolding such definitions is a good idea. But once the type checking finishes, these self-references will become unfoldable. So, at least something needs to be modified -- either the terms or the evaluation context.</p></li></ol><p>Some may argue that one can mutate HOAS by implementing a function like this:</p><pre class="Aya"><code><span class="Keyword">def</span> transformTerm : Term → Term

<span class="Keyword">def</span> transformClosure : Closure → Closure
| mkClosure body ⇒ mkClosure (<span class="Keyword">\\</span>t →
   transformTerm (body t))
<span class="Comment">// ^ body :: Term -&gt; Term</span></code>
</pre><p>This is a very bad idea, because it will run <code>transformTerm</code> every time the closure is applied, while for locally nameless approach, the transformation is done only once. This is caused by the fact that the meta-level language does not have computation under binders, so <code>transformTerm (body t)</code> does not compute for <code>body</code>. If the meta-level language has some symbolic computation abilities, then this approach is slightly more reasonable, but in practice a meta-level language with such abilities is not as efficient.</p><p>We want the benefits of both methods. To do so, Aya introduces a <em>hybrid</em> approach.</p><h2 id="combining-hoas-and-locally-nameless" tabindex="-1">Combining HOAS and Locally Nameless <a class="header-anchor" href="#combining-hoas-and-locally-nameless" aria-label="Permalink to &quot;Combining HOAS and Locally Nameless&quot;">​</a></h2><p>We introduce the closure to allow <em>two</em> representations of closures: one for HOAS, and one for any first-order syntax such as locally nameless. Then, we define substitution on both variants.</p>`,8),e("pre",{class:"Aya"},[a(""),e("code",null,[e("span",{class:"Keyword"},"open"),a(),e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-ClosureV4",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV4"},[e("span",{class:"Data"},"ClosureV4")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-ClosureV4-mkJit",class:"aya-hover","aya-hover-text":"ClosureV4",href:"#Mian-ClosureV4-mkJit"},[e("span",{class:"Constructor"},"mkJit")]),a(" ("),e("a",{id:"v136393487",class:"aya-hover","aya-hover-text":"TermV4 → TermV4",href:"#v136393487"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(" → "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(`)
| `),e("a",{id:"Mian-ClosureV4-mkLn",class:"aya-hover","aya-hover-text":"ClosureV4",href:"#Mian-ClosureV4-mkLn"},[e("span",{class:"Constructor"},"mkLn")]),a(" ("),e("a",{id:"v116669570",class:"aya-hover","aya-hover-text":"TermV4",href:"#v116669570"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(`)

`),e("span",{class:"Comment"},"// The locally-nameless substitution,"),a(`
`),e("span",{class:"Comment"},"// replacing the outermost bound variable in `t` with `s`."),a(`
`),e("span",{class:"Keyword"},"def"),a(),e("a",{id:"Mian-substV4",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-substV4"},[e("span",{class:"Fn"},"substV4")]),a(" ("),e("a",{id:"v1572256205",class:"aya-hover","aya-hover-text":"TermV4",href:"#v1572256205"},[e("span",{class:"LocalVar"},"t")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(") ("),e("a",{id:"v554348863",class:"aya-hover","aya-hover-text":"TermV4",href:"#v554348863"},[e("span",{class:"LocalVar"},"s")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(") : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(" ⇒ "),e("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+R29hbDogR29hbCBvZiB0eXBlCiAgICAgICAgPGEgaHJlZj0iI01pYW4tVGVybVY0Ij48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVY0PC9zcGFuPjwvYT4KICAgICAgICAoTm9ybWFsaXplZDogPGEgaHJlZj0iI01pYW4tVGVybVY0Ij48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVY0PC9zcGFuPjwvYT4pCiAgICAgIENvbnRleHQ6CiAgICAgICAgPGEgaHJlZj0iI3YxNTcyMjU2MjA1Ij48c3BhbiBjbGFzcz0iTG9jYWxWYXIiPnQ8L3NwYW4+PC9hPiA6IDxhIGhyZWY9IiNNaWFuLVRlcm1WNCI+PHNwYW4gY2xhc3M9IkRhdGEiPlRlcm1WNDwvc3Bhbj48L2E+CiAgICAgICAgPGEgaHJlZj0iI3Y1NTQzNDg4NjMiPjxzcGFuIGNsYXNzPSJMb2NhbFZhciI+czwvc3Bhbj48L2E+IDogPGEgaHJlZj0iI01pYW4tVGVybVY0Ij48c3BhbiBjbGFzcz0iRGF0YSI+VGVybVY0PC9zcGFuPjwvYT48L2NvZGU+CjwvcHJlPgo="},[e("span",{class:"Goal"},[e("span",{class:"aya-tooltip","data-tooltip-text":"PHByZSBjbGFzcz0iQXlhIj4KPGNvZGU+PHNwYW4gY2xhc3M9IkNhbGwiPj88YSBocmVmPSIjdjU0ODU1NDU4NiI+XzI8L2E+IDxhIGhyZWY9IiN2MTU3MjI1NjIwNSI+PHNwYW4gY2xhc3M9IkxvY2FsVmFyIj50PC9zcGFuPjwvYT4gPGEgaHJlZj0iI3Y1NTQzNDg4NjMiPjxzcGFuIGNsYXNzPSJMb2NhbFZhciI+czwvc3Bhbj48L2E+PC9zcGFuPjwvY29kZT4KPC9wcmU+Cg=="},"{??}")])]),a(`

`),e("span",{class:"Comment"},"// `elim t` means we only intend to pattern match on `t`."),a(`
`),e("span",{class:"Keyword"},"def"),a(),e("a",{id:"Mian-applyV4",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-applyV4"},[e("span",{class:"Fn"},"applyV4")]),a(" ("),e("a",{id:"v1863702030",class:"aya-hover","aya-hover-text":"ClosureV4",href:"#v1863702030"},[e("span",{class:"LocalVar"},"t")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV4"},[e("span",{class:"Data"},"ClosureV4")]),a(") ("),e("a",{id:"v467796378",class:"aya-hover","aya-hover-text":"TermV4",href:"#v467796378"},[e("span",{class:"LocalVar"},"s")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(") : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(),e("span",{class:"Keyword"},"elim"),a(),e("a",{href:"#v1863702030"},[e("span",{class:"LocalVar"},"t")]),a(`
| `),e("a",{class:"aya-hover","aya-hover-text":"ClosureV4",href:"#Mian-ClosureV4-mkJit"},[e("span",{class:"Constructor"},"mkJit")]),a(),e("a",{id:"v2017797638",class:"aya-hover","aya-hover-text":"TermV4 → TermV4",href:"#v2017797638"},[e("span",{class:"LocalVar"},"body")]),a(" ⇒ "),e("a",{class:"aya-hover","aya-hover-text":"TermV4",href:"#v2017797638"},[e("span",{class:"LocalVar"},"body")]),a(),e("a",{class:"aya-hover","aya-hover-text":"TermV4",href:"#v467796378"},[e("span",{class:"LocalVar"},"s")]),a(`
| `),e("a",{class:"aya-hover","aya-hover-text":"ClosureV4",href:"#Mian-ClosureV4-mkLn"},[e("span",{class:"Constructor"},"mkLn")]),a(),e("a",{id:"v718571091",class:"aya-hover","aya-hover-text":"TermV4",href:"#v718571091"},[e("span",{class:"LocalVar"},"body")]),a(" ⇒ "),e("a",{class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-substV4"},[e("span",{class:"Fn"},"substV4")]),a(),e("a",{class:"aya-hover","aya-hover-text":"TermV4",href:"#v718571091"},[e("span",{class:"LocalVar"},"body")]),a(),e("a",{class:"aya-hover","aya-hover-text":"TermV4",href:"#v467796378"},[e("span",{class:"LocalVar"},"s")])]),a(`
`)],-1),p('<p>During type checking, we use the locally nameless representation <code class="Aya"><a href="#Mian-ClosureV4-mkLn"><span class="Constructor">mkLn</span></a></code>, so we have the freedom to mutate them and transform as we wish. When type checking is done for a cluster of definitions, and the terms are finalized, we generate the meta-level code for the HOAS function bodies, and then we dynamically compile these functions and replace the implementation of closures with the compiled functions in the <code>mkJit</code> variant.</p><p>This process is very similar to JIT-compilation in the usual sense, but slightly different: since the terms are used for type checking, we have to preserve all the type information at runtime, and the JIT-compiled code should deal with open terms. These are not present in the traditional JIT compilation, but with HOAS it&#39;s very easy to do. The dynamic compilation is based on the class loading mechanism of the JVM, therefore we refer to this process as <em>JJH</em> (JVM JIT HOAS). All three components are essential to the approach!</p><p>To support locally nameless we have to also include <code class="Aya"><a href="#Mian-TermV4-bound"><span class="Constructor">bound</span></a></code>:</p>',3),e("pre",{class:"Aya"},[a(""),e("code",null,[e("span",{class:"Keyword"},"inductive"),a(),e("a",{id:"Mian-TermV4",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(" : "),e("span",{class:"Keyword"},"Type"),a(`
| `),e("a",{id:"Mian-TermV4-bound",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-TermV4-bound"},[e("span",{class:"Constructor"},"bound")]),a(" ("),e("a",{id:"v570794077",class:"aya-hover","aya-hover-text":"Nat",href:"#v570794077"},[e("span",{class:"LocalVar"},"deBruijnIndex")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Nat"},[e("span",{class:"Data"},"Nat")]),a(`)
| `),e("a",{id:"Mian-TermV4-free",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-TermV4-free"},[e("span",{class:"Constructor"},"free")]),a(" ("),e("a",{id:"v1928301845",class:"aya-hover","aya-hover-text":"UID",href:"#v1928301845"},[e("span",{class:"LocalVar"},"name")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-UID"},[e("span",{class:"Data"},"UID")]),a(`)
| `),e("a",{id:"Mian-TermV4-lam",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-TermV4-lam"},[e("span",{class:"Constructor"},"lam")]),a(" ("),e("a",{id:"v1789452565",class:"aya-hover","aya-hover-text":"ClosureV4",href:"#v1789452565"},[e("span",{class:"LocalVar"},"body")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV4"},[e("span",{class:"Data"},"ClosureV4")]),a(`)
| `),e("a",{id:"Mian-TermV4-app",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-TermV4-app"},[e("span",{class:"Constructor"},"app")]),a(" ("),e("a",{id:"v1579280783",class:"aya-hover","aya-hover-text":"TermV4",href:"#v1579280783"},[e("span",{class:"LocalVar"},"fun")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(") ("),e("a",{id:"v1370074462",class:"aya-hover","aya-hover-text":"TermV4",href:"#v1370074462"},[e("span",{class:"LocalVar"},"arg")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(")")]),a(`
`)],-1),e("p",null,"In fact, we can extend it with more constructors with closures, and it is very clear how the binders work just by looking at the term structure:",-1),e("pre",{class:"Aya"},[a(""),e("code",null,[a("| "),e("a",{id:"Mian-TermV4-pi",class:"aya-hover","aya-hover-text":"TermV4",href:"#Mian-TermV4-pi"},[e("span",{class:"Constructor"},"pi")]),a(" ("),e("a",{id:"v1595938139",class:"aya-hover","aya-hover-text":"TermV4",href:"#v1595938139"},[e("span",{class:"LocalVar"},"domain")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-TermV4"},[e("span",{class:"Data"},"TermV4")]),a(") ("),e("a",{id:"v1923999715",class:"aya-hover","aya-hover-text":"ClosureV4",href:"#v1923999715"},[e("span",{class:"LocalVar"},"codomain")]),a(" : "),e("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-ClosureV4"},[e("span",{class:"Data"},"ClosureV4")]),a(")")]),a(`
`)],-1),p('<p>We will never forget to substitute the codomain of a pi type because otherwise there will be a type error in the meta-level language.</p><h2 id="related-work" tabindex="-1">Related Work <a class="header-anchor" href="#related-work" aria-label="Permalink to &quot;Related Work&quot;">​</a></h2><p>Coq has two tactics that seemingly do similar things: <code>vm_compute</code> and <code>native_compute</code>. The <code>vm_compute</code> tactic translates Coq terms to an abstract machine (not using HOAS), evaluate it and <em>read-back</em> the result to Coq terms (also not in HOAS), while <code>native_compute</code> produces machine code and do something similar, but using HOAS in the generated code. For the purpose of conversion checking, it is enough to just compare the results of the abstract machine, and reading back the result is not necessary.</p><p>The native code generation is known to be faster than the VM-based approaches, as described in the paper <em>Full Reduction at Full Throttle</em>, and the prior work on <code>vm_compute</code> is described in <em>A Compiled Implementation of Strong Reduction</em>. Both papers can be found in <a href="/guide/readings.html">related papers</a>.</p><p>Aya reuses JVM, a highly optimized VM with two JIT compilers that produce machine code, and has HOAS built-in to the core language, so there is no need of reading back -- the result of compilation is directly used in our core language rather than a separately defined language. This also makes it less error-prone because a bug in the compiled code is a bug in the core language, which is well-understood and well-tested. But then the correctness (mainly type safety) of the core language relies on the correctness of the JJH compiler, which we do not intend to formally verify, but we believe (with reasonable confidence due to the amount of testing) that it is correct.</p><p>Speaking of VM-based evaluation, Lean4 also has an evaluator based on a VM for interpreting code, and Agda also seems to have an abstract machine for reducing code. These two evaluators, together with <code>vm_compute</code>, are based on a VM written by the proof assistant developers, which may not be the most efficient VM, and apparently these VMs do not have a second JIT compiler that produces machine code.</p><p>JJH relies on the fact that the type checker is written in a VM-based language, but we can do the same thing in a native language by using the JIT compilation feature of LLVM or GCC. In the first <em>Workshop on Implementations of Type Systems</em> (WITS), I had the privilege to listen to an exciting talk on an ongoing work on Lean4 that JIT-compiles tactics to native code. They will have a similar advantage to JJH, but it only works on tactics rather than the whole language.</p><p>When I was at the workshop, I was very jealous of the Lean team to have the manpower and resource to do such a thing -- I have been dreaming to do it for a long time (inspired by the work by András Kovács and Minghao Liu on <code>mlang</code>). But look at what we&#39;ve done now! I am satisfied ♪(≧∀≦)ゞ.</p>',8)]))}const P=I(A,[["render",j]]);export{D as __pageData,P as default};
