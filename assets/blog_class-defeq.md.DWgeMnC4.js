import{_ as s,c as e,o as t,a5 as n}from"./chunks/framework.CUWTb1PO.js";const h=JSON.parse('{"title":"Class extension with definitional projection","description":"","frontmatter":{},"headers":[],"relativePath":"blog/class-defeq.md","filePath":"blog/class-defeq.md","lastUpdated":1679761681000}'),i={name:"blog/class-defeq.md"};function o(p,a,l,c,r,m){return t(),e("div",null,[...a[0]||(a[0]=[n(`<h1 id="class-extension-with-definitional-projection" tabindex="-1">Class extension with definitional projection <a class="header-anchor" href="#class-extension-with-definitional-projection" aria-label="Permalink to “Class extension with definitional projection”">​</a></h1><p>We want a class system with the following basic capabilities:</p><ul><li>Classes can be extended with new fields (similar to <code>extends</code> in Java).</li><li>Multiple inheritance is possible, because we can detect conflicts, and in case that really happens, we reject it.</li><li>Subtyping is available and uses coercion. This will be discussed in another post.</li></ul><p>To add more flexibility to it, we want the following feature.</p><h2 id="anonymous-extensions" tabindex="-1">Anonymous extensions <a class="header-anchor" href="#anonymous-extensions" aria-label="Permalink to “Anonymous extensions”">​</a></h2><p>Suppose we have a class <code>Precat</code> for precategories (written in pseudocode):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>class Precat</span></span>
<span class="line"><span>| Ob : Type</span></span>
<span class="line"><span>| Hom : Ob -&gt; Ob -&gt; Type</span></span>
<span class="line"><span>| Hom-set (A B : Ob) : isSet (Hom A B)</span></span>
<span class="line"><span>| id (A : Ob) : Hom A A</span></span>
<span class="line"><span>| ....</span></span></code></pre></div><p>Suppose the syntax for creating an instance of a class is <code>new Precat { Ob := .., Hom := .., ... }</code>. I want the following:</p><ul><li><code>Precat</code> is the type for all instances of the class <code>Precat</code>.</li><li><code>Precat { Ob := Group }</code> is the type for all instances of the class <code>Precat</code> whose <code>Ob</code> field is (definitionally) <code>Group</code>.</li><li><code>Precat { Ob := Group, Hom := GroupHom }</code> is the type for all instances of the class <code>Precat</code> whose <code>Ob</code> field is <code>Group</code> and <code>Hom</code> field is <code>GroupHom</code>.</li><li>etc.</li></ul><p>This is called <em>anonymous class extension</em>, already implemented in the Arend language. As a syntactic sugar, we may write <code>Precat { Ob := Group }</code> as <code>Precat Group</code>, where the application is ordered the same as the fields in the class definition.</p><h2 id="definitional-projection" tabindex="-1">Definitional projection <a class="header-anchor" href="#definitional-projection" aria-label="Permalink to “Definitional projection”">​</a></h2><p>We further want <em>definitional projection</em>:</p><ul><li>Suppose <code>A : Precat Group</code>, then <code>A.Ob</code> is <em>definitionally</em> equal to <code>Group</code>.</li><li>Suppose <code>A : Precat Group GroupHom</code>, then <code>A.Hom</code> is <em>definitionally</em> equal to <code>GroupHom</code>.</li></ul><p>This concludes the basic features of the class system. To implement this, it may seem that we need to have access to types in the normalizer, which makes it very heavy (in contrast to the lightweight normalizer you can have for plain MLTT).</p><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to “Implementation”">​</a></h2><p>A uniform implementation of this definitional projection requires the definitional equality to commute with substitution, say, we may have</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>:</mo><mtext>Precat</mtext><mo>⊢</mo><mi>A</mi><mi mathvariant="normal">.</mi><mtext>Ob</mtext><mo>:</mo><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">{A : \\text{Precat} ⊢ A.\\text{Ob} : \\mathcal U} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">Precat</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mord">.</span><span class="mord text"><span class="mord">Ob</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span></span></p><p>This is a normal form. Then, we have <code>Grp : Precat Group</code> (so <code>Grp.Ob</code> is definitionally equal to <code>Group</code>), and we may perform the substitution <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>Grp</mtext><mi mathvariant="normal">/</mi><mtext>A</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\\text{Grp} / \\text{A}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord text"><span class="mord">Grp</span></span><span class="mord">/</span><span class="mord text"><span class="mord">A</span></span><span class="mclose">]</span></span></span></span> on the above normal form:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Grp</mtext><mo>:</mo><mtext>Precat Group</mtext><mo>⊢</mo><mtext>Grp</mtext><mi mathvariant="normal">.</mi><mtext>Ob</mtext><mo>:</mo><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\\text{Grp} : \\text{Precat}~\\text{Group} ⊢ \\text{Grp}.\\text{Ob} : \\mathcal U </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Grp</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Precat</span></span><span class="mspace nobreak"> </span><span class="mord text"><span class="mord">Group</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Grp</span></span><span class="mord">.</span><span class="mord text"><span class="mord">Ob</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span></p><p>We want the above to be equal to <code>Group</code> as well. Without access to contexts, it seems really hard!</p><p>Here&#39;s a trick: whenever we see <code>A : Precat Group</code>, we <em>elaborate</em> it into (the idea is similar to an η-expansion):</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>A ==&gt; new Precat</span></span>
<span class="line"><span>  { Ob := Group</span></span>
<span class="line"><span>  , Hom := A.Hom</span></span>
<span class="line"><span>  , Hom-set := A.Hom-set</span></span>
<span class="line"><span>  , id := A.id</span></span>
<span class="line"><span>  , ...</span></span>
<span class="line"><span>  }</span></span></code></pre></div><p>By that, we will <em>never</em> have <code>A.Ob</code> in the source language, because it always gets elaborated into <code>Group</code> directly. In case we partially know about <code>A</code> from the type, we really elaborate the type information right into the core term. So, we don&#39;t even have a chance to touch the bare <code>A</code> (not being projected) in the core language, and anything of a class type is <em>always</em> in an introduction form.</p><p>This should implement the definitional projection feature without even modifying the MLTT normalizer.</p><p>The idea of this feature comes from the treatment of extension types inspired from cooltt, see <a href="./path-elab.html">relevant post</a>.</p>`,25)])])}const u=s(i,[["render",o]]);export{h as __pageData,u as default};
