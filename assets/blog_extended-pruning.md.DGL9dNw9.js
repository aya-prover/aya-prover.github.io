import{_,c as z,o as w,j as s,a2 as V,a as e}from"./chunks/framework.BV7BAn2o.js";const T={mounted(){const h=new Map;function d(l){const a=l.querySelectorAll("a[href]");for(const n of a){const o=n.href,r=h.get(o)??new Set;r.add(n),h.set(o,r)}for(const n of a)n.onmouseover=function(){for(const o of h.get(this.href))o.classList.add("hover-highlight")},n.onmouseout=function(){for(const o of h.get(this.href))o.classList.remove("hover-highlight")}}function y(l){return decodeURIComponent(atob(l).split("").map(function(a){return"%"+("00"+a.charCodeAt(0).toString(16)).slice(-2)}).join(""))}const f=(l=>{const a={};return(...n)=>{const o=JSON.stringify(n);return a[o]=a[o]||l(...n)}})(y);class m{constructor(){this.list=[]}dismiss(a){a&&(a.remove(),this.list=this.list.filter(n=>n!==a))}dismissIfNotUsed(a){a&&(a.markedForDismissal=!0,setTimeout(()=>{!a.userIsThinking&&this.allowAutoDismissal(a)&&this.dismiss(a)},1e3))}allowAutoDismissal(a){return a.markedForDismissal&&!a.userClicked}fireAutoDismissalFor(a){let n=this.list.find(o=>o.userCreatedFrom===a);this.dismissIfNotUsed(n)}createHoverFor(a,n,o){let r=this.list.find(i=>i.userCreatedFrom===a);if(r&&r.userClicked)return r;let b=[];const x=this.list.filter(i=>{if(this.allowAutoDismissal(i))return b.push(i),!1;const p=i.userCreatedFrom,u=a;let c=u;for(;c;){if(c===p)return!0;c=c.parentElement}for(c=p;c;){if(c===u)return!0;c=c.parentElement}return!1});b.forEach(i=>this.dismiss(i));let t=document.createElement("div");t.userCreatedFrom=a,t.innerHTML="<span id='AyaTooltipPopupClose'>&times;</span>"+f(n),t.classList.add("AyaTooltipPopup"),d(t);let A=this;if(t.handleEvent=function(i){if(i.type==="click"){this.userClicked=!0,this.markedForDismissal=!1;let p=this.children[0];if(!p)return;let u=this;p.style.visibility="visible",p.addEventListener("click",c=>A.dismiss(u))}i.type==="mouseover"&&(this.userIsThinking=!0),i.type==="mouseout"&&(this.userIsThinking=!1,A.dismissIfNotUsed(this))},t.addEventListener("click",t),t.addEventListener("mouseover",t),t.addEventListener("mouseout",t),o.appendChild(t),t.style.left=`${a.offsetLeft}px`,x.length===0){const i=a.getBoundingClientRect(),p=t.getBoundingClientRect();i.bottom+p.height+30>window.innerHeight?t.style.top=`calc(${a.offsetTop-p.height+8}px - 3em)`:t.style.top=`${a.offsetTop+a.offsetHeight+8}px`}else{const i=Math.max(...x.map(p=>p.offsetTop+p.offsetHeight));t.style.top=`${i+8}px`}return this.list.push(t),t}}let v=new m;function g(l){return function(){let a=this;const n=a.getAttribute("data-tooltip-text");n&&(l?v.createHoverFor(a,n,document.body):v.fireAutoDismissalFor(a))}}d(document);{let l=document.getElementsByClassName("aya-tooltip");for(let a=0;a<l.length;a++){let n=l[a];n.hasAttribute("data-tooltip-text")&&(n.onmouseover=g(!0),n.onmouseout=g(!1))}}}},P=JSON.parse('{"title":"Extended pruning for pattern unification","description":"","frontmatter":{"lastUpdated":"2024-12-15T22:37:34.000Z"},"headers":[],"relativePath":"blog/extended-pruning.md","filePath":"blog/extended-pruning.md","lastUpdated":1734302254000}');function C(h,d,y,k,f,m){return w(),z("div",null,d[0]||(d[0]=[s("h1",{id:"extended-pruning-for-pattern-unification",tabindex:"-1"},[e("Extended pruning for pattern unification "),s("a",{class:"header-anchor",href:"#extended-pruning-for-pattern-unification","aria-label":'Permalink to "Extended pruning for pattern unification"'},"​")],-1),s("pre",{class:"Aya"},[e(""),s("code",null,[s("span",{class:"Keyword"},"prim"),e(),s("a",{id:"Mian-I",class:"aya-hover","aya-hover-text":"ISet",href:"#Mian-I"},[s("span",{class:"Primitive"},"I")]),e(`
`),s("span",{class:"Keyword"},"prim"),e(),s("a",{id:"Mian-Path",class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Path"},[s("span",{class:"Primitive"},"Path")]),e(" ("),s("a",{id:"v1816725203",class:"aya-hover","aya-hover-text":"I → Type 0",href:"#v1816725203"},[s("span",{class:"LocalVar"},"A")]),e(" : "),s("a",{class:"aya-hover","aya-hover-text":"ISet",href:"#Mian-I"},[s("span",{class:"Primitive"},"I")]),e(" → "),s("span",{class:"Keyword"},"Type"),e(") ("),s("a",{id:"v1038677529",class:"aya-hover","aya-hover-text":"A 0",href:"#v1038677529"},[s("span",{class:"LocalVar"},"a")]),e(" : "),s("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1816725203"},[s("span",{class:"LocalVar"},"A")]),e(" 0) ("),s("a",{id:"v716487794",class:"aya-hover","aya-hover-text":"A 1",href:"#v716487794"},[s("span",{class:"LocalVar"},"b")]),e(" : "),s("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1816725203"},[s("span",{class:"LocalVar"},"A")]),e(" 1) : "),s("span",{class:"Keyword"},"Type")]),e(`
`)],-1),s("p",null,"The vanilla pattern unification is very limited. Consider:",-1),s("pre",{class:"Aya"},[e(""),s("code",null,[e(),s("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Path"},[s("span",{class:"Primitive"},"Path")]),e(" ("),s("span",{class:"Keyword"},"fn"),e(),s("a",{id:"v284686302",href:"#v284686302"},[s("span",{class:"LocalVar"},"i")]),e(" ⇒ "),s("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#Mian-Vec"},[s("span",{class:"Data"},"Vec")]),e(" ("),s("a",{class:"aya-hover","aya-hover-text":"Nat",href:"#Mian-2b-assoc"},[s("span",{class:"Fn"},"+-assoc")]),e(),s("a",{class:"aya-hover","aya-hover-text":"I",href:"#v284686302"},[s("span",{class:"LocalVar"},"i")]),e(") "),s("a",{class:"aya-hover","aya-hover-text":"Type 0",href:"#v1894369629"},[s("span",{class:"Generalized"},"A")]),e(`)
      ((`),s("a",{class:"aya-hover","aya-hover-text":"Vec n A",href:"#v1719072416"},[s("span",{class:"LocalVar"},"xs")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec (?n n A m o xs ys zs + ?m n A m o xs ys zs) (?A n A m o xs ys zs)",href:"#Mian-2b2b"},[s("span",{class:"Fn"},"++")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec m A",href:"#v2092801316"},[s("span",{class:"LocalVar"},"ys")]),e(") "),s("a",{class:"aya-hover","aya-hover-text":"Vec ((n + m) + o) A",href:"#Mian-2b2b"},[s("span",{class:"Fn"},"++")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec o A",href:"#v376635015"},[s("span",{class:"LocalVar"},"zs")]),e(`)
      (`),s("a",{class:"aya-hover","aya-hover-text":"Vec n A",href:"#v1719072416"},[s("span",{class:"LocalVar"},"xs")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec (?n n A m o xs ys zs + ?m n A m o xs ys zs) (?A n A m o xs ys zs)",href:"#Mian-2b2b"},[s("span",{class:"Fn"},"++")]),e(" ("),s("a",{class:"aya-hover","aya-hover-text":"Vec m A",href:"#v2092801316"},[s("span",{class:"LocalVar"},"ys")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec (?n n A m o xs ys zs + ?m n A m o xs ys zs) (?A n A m o xs ys zs)",href:"#Mian-2b2b"},[s("span",{class:"Fn"},"++")]),e(),s("a",{class:"aya-hover","aya-hover-text":"Vec o A",href:"#v376635015"},[s("span",{class:"LocalVar"},"zs")]),e("))")]),e(`
`)],-1),V(`<p>This is the equality between two sized vectors: <code>(xs ++ (ys ++ zs))</code> and <code>((xs ++ ys) ++ zs)</code>, the left hand side has type <code>Vec (xs.size ++ (ys.size ++ zs.size)) A</code>, and the right hand side has type <code>Vec ((xs.size ++ ys.size) ++ zs.size)</code>.</p><p>So, the equality type is heterogeneous, and I introduce a type <code>Vec (+-assoc i) A</code> for it, where <code class="Aya"><a href="#Mian-2b-assoc"><span class="Fn">+-assoc</span></a></code> is the associativity.</p><p>So this should type check, right? But pattern unification fails! I&#39;ve left the two sides of <code class="Aya"><a href="#Mian-2b-assoc"><span class="Fn">+-assoc</span></a></code> implicit, so I&#39;m supposed to infer what numbers&#39; associativity I care about, using pattern unification.</p><p>Then, pattern unification <em>fails</em> because the constraints are generated from cubical boundaries, where the &quot;interval&quot; variable is substituted to its sides. So, we have this type (the <code class="Aya"><a href="#Mian-Path"><span class="Primitive">Path</span></a></code> is called <code>PathP</code> in Agda):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Γ ­⊢ Path (fn i =&gt; Vec (+-assoc i) Nat) vecA vecB</span></span></code></pre></div><p>Note the type of <code class="Aya"><a href="#Mian-2b-assoc"><span class="Fn">+-assoc</span></a></code> is <code class="Aya"><span class="Keyword">Fn</span> (<a id="v1533985074" href="#v1533985074">o</a> <a id="v1548010882" href="#v1548010882">p</a> <a id="v1741786839" href="#v1741786839">q</a> : <a href="#Mian-Nat"><span class="Data">Nat</span></a>) → ((<a href="#v1533985074"><span class="LocalVar">o</span></a> <a href="#Mian-2b"><span class="Fn">+</span></a> <a href="#v1548010882"><span class="LocalVar">p</span></a>) <a href="#Mian-2b"><span class="Fn">+</span></a> <a href="#v1741786839"><span class="LocalVar">q</span></a>) <a href="#Mian-3d"><span class="Fn">=</span></a> (<a href="#v1533985074"><span class="LocalVar">o</span></a> <a href="#Mian-2b"><span class="Fn">+</span></a> (<a href="#v1548010882"><span class="LocalVar">p</span></a> <a href="#Mian-2b"><span class="Fn">+</span></a> <a href="#v1741786839"><span class="LocalVar">q</span></a>))</code>.</p><p>So elaboration inserts metavariables:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Γ ­⊢ Path (fn i =&gt; Vec (+-assoc {?} {?} {?} i) Nat) vecA vecB</span></span></code></pre></div><p>Where these metavariables have the following scope:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Γ , i : I ­⊢ ? : Nat</span></span></code></pre></div><p>Note that the <code>i : I</code> binding is in-scope. So the metavariables with their spines added together becomes:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Γ ­⊢ Path (fn i =&gt; Vec (+-assoc {?a Γ i} {?b Γ i} {?c Γ i} i) Nat) vecA vecB</span></span></code></pre></div><p>Then, we get the following tycking problems, according to the rules of <code class="Aya"><a href="#Mian-Path"><span class="Primitive">Path</span></a></code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vecA : Vec (+-assoc {?a Γ 0} {?b Γ 0} {?c Γ 0} 0) Nat</span></span>
<span class="line"><span>vecB : Vec (+-assoc {?a Γ 1} {?b Γ 1} {?c Γ 1} 1) Nat</span></span></code></pre></div><p>Look at the spines of all of these metavariables. None of them are in pattern fragment. So <em>every</em> equality constraint cannot be solved by pattern, because they&#39;re always equality <em>after a substitution</em>!</p><p>This can be solved by further extending your algorithm with pruning or a constraint system with a &quot;lax&quot; mode of solving metas when your equations rely essentially on non-pattern equations, but I feel it has defeated the point of finding the most general solution, which I used to believe to be the purpose of pattern unification....</p><h2 id="case-study" tabindex="-1">Case Study <a class="header-anchor" href="#case-study" aria-label="Permalink to &quot;Case Study&quot;">​</a></h2><p>Right now Aya will try to prune these non-pattern arguments out and try to solve them. This obviously generates non-unique solutions, but I think it will be useful in practice.</p><p>In Agda, the following code is in the library:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>++-assoc : ∀ {m n k} (xs : Vec A m) (ys : Vec A n) (zs : Vec A k) →</span></span>
<span class="line"><span>          PathP (λ i → Vec A (+-assoc m n k (~ i)))</span></span>
<span class="line"><span>          ((xs ++ ys) ++ zs) (xs ++ ys ++ zs)</span></span>
<span class="line"><span>++-assoc {m = zero} [] ys zs = refl</span></span>
<span class="line"><span>++-assoc {m = suc m} (x ∷ xs) ys zs i = x ∷ ++-assoc xs ys zs i</span></span></code></pre></div><p>However, if we replace the <code>m</code> with <code>_</code>, Agda will fail with the following error:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Failed to solve the following constraints:</span></span>
<span class="line"><span>  _41 (xs = (x ∷ xs)) (ys = ys) (zs = zs) = x ∷ ++-assoc xs ys zs i1</span></span>
<span class="line"><span>    : Vec A</span></span>
<span class="line"><span>      (+-assoc (_m_39 (xs = (x ∷ xs)) (ys = ys) (zs = zs) (i = i1)) n k</span></span>
<span class="line"><span>       (~ i1))</span></span>
<span class="line"><span>    (blocked on any(_41, _57))</span></span>
<span class="line"><span>  _40 (xs = (x ∷ xs)) (ys = ys) (zs = zs) = x ∷ ++-assoc xs ys zs i0</span></span>
<span class="line"><span>    : Vec A</span></span>
<span class="line"><span>      (+-assoc (_m_39 (xs = (x ∷ xs)) (ys = ys) (zs = zs) (i = i0)) n k</span></span>
<span class="line"><span>       (~ i0))</span></span>
<span class="line"><span>    (blocked on any(_40, _57))</span></span>
<span class="line"><span>  +-assoc (_m_39 (xs = xs) (ys = ys) (zs = zs) (i = i)) n k (~ i)</span></span>
<span class="line"><span>    = _n_49</span></span>
<span class="line"><span>    : ℕ</span></span>
<span class="line"><span>    (blocked on _n_49)</span></span>
<span class="line"><span>  +-assoc (_m_39 (xs = (x ∷ xs)) (ys = ys) (zs = zs) (i = i)) n k</span></span>
<span class="line"><span>  (~ i)</span></span>
<span class="line"><span>    = ℕ.suc _n_49</span></span>
<span class="line"><span>    : ℕ</span></span>
<span class="line"><span>    (blocked on _m_39)</span></span>
<span class="line"><span>  _40 (xs = []) (ys = ys) (zs = zs)</span></span>
<span class="line"><span>    = _41 (xs = []) (ys = ys) (zs = zs)</span></span>
<span class="line"><span>    : _x.A_43</span></span>
<span class="line"><span>    (blocked on any(_40, _41))</span></span>
<span class="line"><span>  _x.A_43</span></span>
<span class="line"><span>    = Vec A</span></span>
<span class="line"><span>      (+-assoc (_m_39 (xs = []) (ys = ys) (zs = zs) (i = i)) n k (~ i))</span></span>
<span class="line"><span>    : Type</span></span>
<span class="line"><span>    (blocked on _x.A_43)</span></span>
<span class="line"><span>  _m_39 (i = i0) = m : ℕ (blocked on _m_39)</span></span>
<span class="line"><span>  _m_39 (i = i1) + (n + k) = m + (n + k) : ℕ (blocked on _m_39)</span></span></code></pre></div><p>In Aya, this will raise the following warning:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  6 │       def ++-assoc-type (xs : Vec n A) (ys : Vec m A) (zs : Vec o A)</span></span>
<span class="line"><span>  7 │         =&gt; Path (fn i =&gt; Vec (+-assoc i) A)</span></span>
<span class="line"><span>  8 │         (xs ++ (ys ++ zs))</span></span>
<span class="line"><span>    │          ╰──────────────╯ ?a n A m o xs ys zs 0 &gt;= n, ?b n A m o xs ys zs 0 &gt;= m,</span></span>
<span class="line"><span>                                ?c n A m o xs ys zs 0 &gt;= o</span></span>
<span class="line"><span>  9 │         ((xs ++ ys) ++ zs)</span></span>
<span class="line"><span>    │          ╰──────────────╯</span></span>
<span class="line"><span>    │          ╰──────────────╯ ?a n A m o xs ys zs 1 &gt;= n, ?b n A m o xs ys zs 1 &gt;= m,</span></span>
<span class="line"><span>                                ?c n A m o xs ys zs 1 &gt;= o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Info: Solving equation(s) with not very general solution(s)</span></span></code></pre></div><p>The inline equations are the type checking problems that Aya did something bad to solve.</p><p>Conor McBride told me pattern unification is a good algorithm, but the problem of interest might not be what we think it is. It is good for <em>undergraduate induction</em>, i.e. the object being induct on is a variable, and the <em>motive</em> of such induction is pattern. This is an enlightening perspective! But now that we have more problems, I think we might want to extend it. Just think about how many people use <code>--lossy-unification</code> in Agda.</p>`,26)]))}const L=_(T,[["render",C]]);export{P as __pageData,L as default};
